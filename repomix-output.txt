This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-19T18:25:34.935Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/
  workflows/
    build.yml
    release.yml
    test.yml
  dependabot.yml
  FUNDING.yml
app-authenticator/
  src/
    main/
      java/
        netzbegruenung/
          keycloak/
            app/
              actiontoken/
                ActionTokenUtil.java
                AppAuthActionToken.java
                AppAuthActionTokenHandler.java
                AppSetupActionToken.java
                AppSetupActionTokenHandler.java
              credentials/
                AppCredentialData.java
                AppCredentialModel.java
              dto/
                ChallengeConverter.java
                ChallengeDto.java
              jpa/
                Challenge.java
                ChallengeJpaEntityProvider.java
                ChallengeJpaEntityProviderFactory.java
              messaging/
                FcmMessagingService.java
                MessagingService.java
                MessagingServiceFactory.java
              rest/
                ChallengeResourceProvider.java
                ChallengeResourceProviderFactory.java
                DeviceConnection.java
                Message.java
                StatusResourceProvider.java
                StatusResourceProviderFactory.java
              AppAuthenticator.java
              AppAuthenticatorFactory.java
              AppCredentialProvider.java
              AppCredentialProviderFactory.java
              AppRequiredAction.java
              AppRequiredActionFactory.java
              AuthenticationUtil.java
      resources/
        META-INF/
          services/
            org.keycloak.authentication.actiontoken.ActionTokenHandlerFactory
            org.keycloak.authentication.AuthenticatorFactory
            org.keycloak.authentication.RequiredActionFactory
            org.keycloak.connections.jpa.entityprovider.JpaEntityProviderFactory
            org.keycloak.credential.CredentialProviderFactory
            org.keycloak.services.resource.RealmResourceProviderFactory
          challenge-changelog.xml
        theme-resources/
          messages/
            messages_de.properties
            messages_en.properties
          templates/
            app-auth-selection.ftl
            app-auth-setup.ftl
            app-login.ftl
  pom.xml
  README.md
app-authenticator-cli/
  .gitignore
  authenticator.js
  package.json
enforce-mfa/
  src/
    main/
      java/
        netzbegruenung/
          keycloak/
            enforce_mfa/
              EnforceMfaAuthenticator.java
              EnforceMfaAuthenticatorFactory.java
      resources/
        META-INF/
          services/
            org.keycloak.authentication.AuthenticatorFactory
        theme-resources/
          messages/
            messages_de.properties
            messages_en.properties
          templates/
            enforce-mfa.ftl
  pom.xml
  README.md
sms-authenticator/
  src/
    main/
      java/
        netzbegruenung/
          keycloak/
            authenticator/
              credentials/
                SmsAuthCredentialData.java
                SmsAuthCredentialModel.java
              gateway/
                ApiSmsService.java
                SmsService.java
                SmsServiceFactory.java
              PhoneNumberRequiredAction.java
              PhoneNumberRequiredActionFactory.java
              PhoneValidationRequiredAction.java
              PhoneValidationRequiredActionFactory.java
              SmsAuthCredentialProvider.java
              SmsAuthCredentialProviderFactory.java
              SmsAuthenticator.java
              SmsAuthenticatorFactory.java
      resources/
        META-INF/
          services/
            org.keycloak.authentication.AuthenticatorFactory
            org.keycloak.authentication.RequiredActionFactory
            org.keycloak.credential.CredentialProviderFactory
        theme-resources/
          messages/
            messages_de.properties
            messages_en.properties
            messages_fi.properties
          templates/
            login-sms.ftl
            mobile_number_form.ftl
  pom.xml
  README.md
.editorconfig
.gitignore
LICENSE
pom.xml
README.md

================================================================
Repository Files
================================================================

================
File: .github/workflows/build.yml
================
name: Reusable build workflow

on: workflow_call

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Build with Maven
        run: mvn -B install --file pom.xml
      - run: |
          mkdir staging
          cp sms-authenticator/target/*.jar staging
          cp app-authenticator/target/*.jar staging
          cp enforce-mfa/target/*.jar staging
      - name: Create hash files
        run: |
          for jar in *.jar
          do
              sha512sum $jar | awk '{ print $1 }' > "${jar}.sha512"
          done
        working-directory: staging
      - uses: actions/upload-artifact@v4
        with:
          name: packages
          path: staging

================
File: .github/workflows/release.yml
================
# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven
# https://github.com/actions/create-release

name: Release

on:
  push:
    tags:
      - v**

jobs:
  build:
    uses: ./.github/workflows/build.yml
  release:
    needs: build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Download math result for job 2
        uses: actions/download-artifact@v4
        with:
          name: packages
          path: staging
      - name: "Create release"
        run: gh release create ${GITHUB_REF_NAME} staging/* --generate-notes --verify-tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: .github/workflows/test.yml
================
name: Test

on:
  push:
    branches:
      - '**'

jobs:
  build:
    uses: ./.github/workflows/build.yml
  # TODO further tests

================
File: .github/dependabot.yml
================
version: 2
updates:
  - package-ecosystem: "maven"
    directory: "/"
    schedule:
      interval: "weekly"
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"

================
File: .github/FUNDING.yml
================
custom: https://www.paypal.me/dasniko

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/actiontoken/ActionTokenUtil.java
================
package netzbegruenung.keycloak.app.actiontoken;

import org.jboss.logging.Logger;
import org.keycloak.authentication.AuthenticationProcessor;
import org.keycloak.authentication.actiontoken.DefaultActionToken;
import org.keycloak.common.util.Time;
import org.keycloak.models.*;
import org.keycloak.services.Urls;
import org.keycloak.services.managers.AuthenticationSessionManager;
import org.keycloak.sessions.AuthenticationSessionCompoundId;
import org.keycloak.sessions.AuthenticationSessionModel;

import jakarta.ws.rs.core.UriInfo;
import java.lang.reflect.InvocationTargetException;
import java.net.URI;

public class ActionTokenUtil {

	final static private Logger logger = Logger.getLogger(ActionTokenUtil.class);

	public static AuthenticationSessionModel getOriginalAuthSession(KeycloakSession session, RealmModel realm, String originalAuthSessionId) {
		AuthenticationSessionManager asm = new AuthenticationSessionManager(session);
		AuthenticationSessionCompoundId compoundId = AuthenticationSessionCompoundId.encoded(originalAuthSessionId);
		ClientModel originalClient = realm.getClientById(compoundId.getClientUUID());
		return asm.getAuthenticationSessionByIdAndClient(
			realm,
			compoundId.getRootSessionId(),
			originalClient,
			compoundId.getTabId()
		);
	}

	public static URI createActionToken(Class<?> actionTokenClass, AuthenticationSessionModel authSession, KeycloakSession session, RealmModel realm, UserModel user, UriInfo uriInfo) {
		try {
			final String clientId = authSession.getClient().getClientId();
			DefaultActionToken token = (DefaultActionToken) actionTokenClass.getDeclaredConstructor(String.class, Integer.class, String.class, String.class).newInstance(
				user.getId(),
				Time.currentTime() + realm.getActionTokenGeneratedByUserLifespan(),
				AuthenticationSessionCompoundId.fromAuthSession(authSession).getEncodedId(),
				clientId
			);
			return Urls
				.actionTokenBuilder(
					uriInfo.getBaseUri(),
					token.serialize(session, realm, uriInfo),
					clientId,
					authSession.getTabId(),
					AuthenticationProcessor.getClientData(session, authSession)
				)
				.build(realm.getName());
		} catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
			throw new RuntimeException(e);
		}

	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/actiontoken/AppAuthActionToken.java
================
package netzbegruenung.keycloak.app.actiontoken;

import com.fasterxml.jackson.annotation.JsonProperty;
import org.keycloak.authentication.actiontoken.DefaultActionToken;

public class AppAuthActionToken extends DefaultActionToken {
	public static final String TOKEN_TYPE = "app-auth-action-token";

	private static final String JSON_FIELD_ORIGINAL_AUTHENTICATION_SESSION_ID = "oasid";

	@JsonProperty(value = JSON_FIELD_ORIGINAL_AUTHENTICATION_SESSION_ID)
	private String originalAuthenticationSessionId;

	public AppAuthActionToken(String userId, Integer absoluteExpirationInSecs, String compoundAuthenticationSessionId, String clientId) {
		super(userId, TOKEN_TYPE, absoluteExpirationInSecs, null);
		this.issuer = clientId;
		this.originalAuthenticationSessionId = compoundAuthenticationSessionId;
	}

	private AppAuthActionToken() {
		// Required to deserialize from JWT
		super();
	}

	public String getOriginalAuthenticationSessionId() {
		return originalAuthenticationSessionId;
	}

	public void setOriginalAuthenticationSessionId(String originalCompoundAuthenticationSessionId) {
		this.originalAuthenticationSessionId = originalCompoundAuthenticationSessionId;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/actiontoken/AppAuthActionTokenHandler.java
================
package netzbegruenung.keycloak.app.actiontoken;

import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceException;
import netzbegruenung.keycloak.app.AppAuthenticator;
import netzbegruenung.keycloak.app.AppCredentialProvider;
import netzbegruenung.keycloak.app.AppCredentialProviderFactory;
import netzbegruenung.keycloak.app.AuthenticationUtil;
import netzbegruenung.keycloak.app.credentials.AppCredentialData;
import netzbegruenung.keycloak.app.credentials.AppCredentialModel;
import netzbegruenung.keycloak.app.rest.StatusResourceProvider;
import org.jboss.logging.Logger;
import org.keycloak.authentication.actiontoken.AbstractActionTokenHandler;
import org.keycloak.authentication.actiontoken.ActionTokenContext;
import org.keycloak.connections.jpa.JpaConnectionProvider;
import org.keycloak.credential.CredentialModel;
import org.keycloak.credential.CredentialProvider;
import org.keycloak.events.Errors;
import org.keycloak.events.EventType;
import org.keycloak.models.jpa.entities.RealmEntity;
import org.keycloak.services.messages.Messages;
import org.keycloak.sessions.AuthenticationSessionModel;

import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.Response;
import java.util.HashMap;
import java.util.Map;

public class AppAuthActionTokenHandler extends AbstractActionTokenHandler<AppAuthActionToken> {

	private final Logger logger = Logger.getLogger(AppAuthActionTokenHandler.class);

	public AppAuthActionTokenHandler() {
		super(
			AppAuthActionToken.TOKEN_TYPE,
			AppAuthActionToken.class,
			Messages.INVALID_REQUEST,
			EventType.EXECUTE_ACTION_TOKEN,
			Errors.INVALID_REQUEST
		);
	}

	@Override
	public Response handleToken(AppAuthActionToken token, ActionTokenContext<AppAuthActionToken> tokenContext) {
		MultivaluedMap<String, String> queryParameters = tokenContext.getRequest().getUri().getQueryParameters();
		String granted = queryParameters.getFirst("granted");

		AuthenticationSessionModel authSession = ActionTokenUtil.getOriginalAuthSession(
			tokenContext.getSession(),
			tokenContext.getRealm(),
			token.getOriginalAuthenticationSessionId()
		);

		if (authSession == null) {
			logger.errorf("App Authentication rejected: Auth session not found for user [%s]", token.getUserId());
			return Response.status(Response.Status.FORBIDDEN).build();
		}

		String authSessionGranted = authSession.getAuthNote(AppAuthenticator.APP_AUTH_GRANTED_NOTE);

		if (authSessionGranted != null && !Boolean.parseBoolean(authSessionGranted)) {
			return Response.status(Response.Status.FORBIDDEN).build();
		}

		if (granted == null) {
			logger.warnf("App authentication rejected: missing query param \"granted\" for user ID [%s]", token.getUserId());
			authSession.setAuthNote(StatusResourceProvider.READY, Boolean.toString(true));
			return Response.status(Response.Status.BAD_REQUEST).build();
		}

		Map<String, String> signatureMap = AuthenticationUtil.getSignatureMap(tokenContext.getRequest().getHttpHeaders().getRequestHeader("Signature"));
		if (signatureMap == null) {
			logger.warnf("App authentication rejected: missing or incomplete signature header for user ID [%s]", token.getUserId());
			authSession.setAuthNote(StatusResourceProvider.READY, Boolean.toString(true));
			return Response.status(Response.Status.BAD_REQUEST).build();
		}

		AppCredentialProvider appCredentialProvider = (AppCredentialProvider) tokenContext
			.getSession()
			.getProvider(CredentialProvider.class, AppCredentialProviderFactory.PROVIDER_ID);
		CredentialModel appCredentialModel = appCredentialProvider
			.getCredentialModel(authSession.getAuthenticatedUser(), authSession.getAuthNote("credentialId"));

		AppCredentialData appCredentialData = AppCredentialModel.createFromCredentialModel(appCredentialModel).getAppCredentialData();

		Map<String, String> signatureStringMap = new HashMap<>();
		signatureStringMap.put("created", authSession.getAuthNote("timestamp"));
		signatureStringMap.put("secret", authSession.getAuthNote("secret"));
		signatureStringMap.put("granted", granted);

		boolean verified = AuthenticationUtil.verifyChallenge(
			authSession.getAuthenticatedUser(),
			appCredentialData,
			AuthenticationUtil.getSignatureString(signatureStringMap),
			signatureMap.get("signature")
		);

		if (!verified) {
			authSession.setAuthNote(StatusResourceProvider.READY, Boolean.toString(true));
			return Response.status(Response.Status.FORBIDDEN).build();
		}

		if (!Boolean.parseBoolean(granted)) {
			authSession.setAuthNote(AppAuthenticator.APP_AUTH_GRANTED_NOTE, Boolean.toString(false));
		} else {
			authSession.setAuthNote(AppAuthenticator.APP_AUTH_GRANTED_NOTE, Boolean.toString(true));
		}

		authSession.setAuthNote(StatusResourceProvider.READY, Boolean.toString(true));

		try {
			EntityManager em = tokenContext.getSession().getProvider(JpaConnectionProvider.class).getEntityManager();
			RealmEntity realm = em.getReference(RealmEntity.class, tokenContext.getRealm().getId());
			em.createNamedQuery("Challenge.deleteByRealmAndDeviceId")
				.setParameter("realm", realm)
				.setParameter("deviceId", appCredentialData.getDeviceId())
				.executeUpdate();
		} catch (PersistenceException e) {
			logger.error(String.format("Failed to delete challenge for device ID %s", appCredentialData.getDeviceId()), e);
		}

		return Response.status(Response.Status.NO_CONTENT).build();
	}

	@Override
	public boolean canUseTokenRepeatedly(AppAuthActionToken token, ActionTokenContext<AppAuthActionToken> tokenContext) {
		return false;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/actiontoken/AppSetupActionToken.java
================
package netzbegruenung.keycloak.app.actiontoken;

import com.fasterxml.jackson.annotation.JsonProperty;
import org.keycloak.authentication.actiontoken.DefaultActionToken;

public class AppSetupActionToken extends DefaultActionToken {

	public static final String TOKEN_TYPE = "app-setup-action-token";

	private static final String JSON_FIELD_ORIGINAL_AUTHENTICATION_SESSION_ID = "oasid";

	@JsonProperty(value = JSON_FIELD_ORIGINAL_AUTHENTICATION_SESSION_ID)
	private String originalAuthenticationSessionId;

	public AppSetupActionToken(String userId, Integer absoluteExpirationInSecs, String compoundAuthenticationSessionId, String clientId) {
		super(userId, TOKEN_TYPE, absoluteExpirationInSecs, null);
		this.issuer = clientId;
		this.originalAuthenticationSessionId = compoundAuthenticationSessionId;
	}

	private AppSetupActionToken() {
		// Required to deserialize from JWT
		super();
	}

	public String getOriginalAuthenticationSessionId() {
		return originalAuthenticationSessionId;
	}

	public void setOriginalAuthenticationSessionId(String originalCompoundAuthenticationSessionId) {
		this.originalAuthenticationSessionId = originalCompoundAuthenticationSessionId;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/actiontoken/AppSetupActionTokenHandler.java
================
package netzbegruenung.keycloak.app.actiontoken;

import netzbegruenung.keycloak.app.AppCredentialProviderFactory;
import netzbegruenung.keycloak.app.credentials.AppCredentialModel;
import netzbegruenung.keycloak.app.rest.StatusResourceProvider;
import org.keycloak.authentication.actiontoken.AbstractActionTokenHandler;
import org.keycloak.authentication.actiontoken.ActionTokenContext;
import org.keycloak.credential.CredentialProvider;
import org.keycloak.events.Errors;
import org.keycloak.events.EventType;
import org.keycloak.models.UserModel;
import org.keycloak.services.messages.Messages;
import org.keycloak.sessions.AuthenticationSessionModel;

import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.Response;

public class AppSetupActionTokenHandler extends AbstractActionTokenHandler<AppSetupActionToken> {
	public AppSetupActionTokenHandler() {
		super(
			AppSetupActionToken.TOKEN_TYPE,
			AppSetupActionToken.class,
			Messages.INVALID_REQUEST,
			EventType.EXECUTE_ACTION_TOKEN,
			Errors.INVALID_REQUEST
		);
	}

	@Override
	public Response handleToken(AppSetupActionToken token, ActionTokenContext<AppSetupActionToken> tokenContext) {
		MultivaluedMap<String, String> queryParameters = tokenContext.getRequest().getUri().getQueryParameters();
		String deviceId = queryParameters.getFirst("device_id");
		String deviceOs = queryParameters.getFirst("device_os");
		String publicKey = queryParameters.getFirst("public_key");
		String keyAlgorithm = queryParameters.getFirst("key_algorithm");
		String signatureAlgorithm = queryParameters.getFirst("signature_algorithm");
		String devicePushId = queryParameters.getFirst("device_push_id");

		if (
			deviceId == null
			|| deviceOs == null
			|| publicKey == null
			|| keyAlgorithm == null
			|| signatureAlgorithm == null
		) {
			return Response.status(400).build();
		}

		UserModel user = tokenContext.getAuthenticationSession().getAuthenticatedUser();
		long count = user.credentialManager()
			.getStoredCredentialsByTypeStream(AppCredentialModel.TYPE)
			.map(AppCredentialModel::createFromCredentialModel)
			.filter(c -> c.getAppCredentialData().getDeviceId().equals(deviceId))
			.count();

		AuthenticationSessionModel authSession = ActionTokenUtil.getOriginalAuthSession(
			tokenContext.getSession(),
			tokenContext.getRealm(),
			token.getOriginalAuthenticationSessionId()
		);

		if (authSession == null) {
			return Response.status(Response.Status.FORBIDDEN).build();
		}

		if (count > 0) {
			authSession.setAuthNote("duplicateDeviceId", Boolean.toString(true));
			authSession.setAuthNote(StatusResourceProvider.READY, Boolean.toString(true));
			return Response.status(400).build();
		}

		CredentialProvider appCredentialProvider = tokenContext.getSession().getProvider(
			CredentialProvider.class,
			AppCredentialProviderFactory.PROVIDER_ID
		);
		appCredentialProvider.createCredential(
			tokenContext.getRealm(),
			user,
			AppCredentialModel.createAppCredential(publicKey, deviceId, deviceOs, keyAlgorithm, signatureAlgorithm, devicePushId)
		);

		authSession.setAuthNote("appSetupSuccessful", Boolean.toString(true));
		authSession.setAuthNote(StatusResourceProvider.READY, Boolean.toString(true));

		return Response.status(201).build();
	}

	@Override
	public boolean canUseTokenRepeatedly(AppSetupActionToken token, ActionTokenContext<AppSetupActionToken> tokenContext) {
		return false;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/credentials/AppCredentialData.java
================
package netzbegruenung.keycloak.app.credentials;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;

public class AppCredentialData {
	private final String publicKey;

	private final String deviceId;
	private final String deviceOs;

	private final String keyAlgorithm;

	private final String signatureAlgorithm;

	private final String devicePushId;


	@JsonCreator
	public AppCredentialData(
		@JsonProperty("publicKey") String publicKey,
		@JsonProperty("deviceId") String deviceId,
		@JsonProperty("deviceOs") String deviceOs,
		@JsonProperty("keyAlgorithm") String keyAlgorithm,
		@JsonProperty("signatureAlgorithm") String signatureAlgorithm,
		@JsonProperty("devicePushId") String devicePushId
	) {
		this.publicKey = publicKey;
		this.deviceId = deviceId;
		this.deviceOs = deviceOs;
		this.keyAlgorithm = keyAlgorithm;
		this.signatureAlgorithm = signatureAlgorithm;
		this.devicePushId = devicePushId;
	}

	public String getPublicKey() {
		return publicKey;
	}

	public String getDeviceId() {
		return deviceId;
	}

	public String getDeviceOs() {
		return deviceOs;
	}

	public String getKeyAlgorithm() {
		return keyAlgorithm;
	}

	public String getDevicePushId() {
		return devicePushId;
	}

	public String getSignatureAlgorithm() {
		return signatureAlgorithm;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/credentials/AppCredentialModel.java
================
package netzbegruenung.keycloak.app.credentials;

import org.keycloak.common.util.Time;
import org.keycloak.credential.CredentialModel;
import org.keycloak.util.JsonSerialization;

import java.io.IOException;

public class AppCredentialModel extends CredentialModel {

	public static final String TYPE = "APP_CREDENTIAL";

	private final AppCredentialData credentialData;

	private AppCredentialModel(AppCredentialData credentialData) {
		this.credentialData = credentialData;
	}

	private AppCredentialModel(String publicKey, String deviceId, String deviceOs, String keyAlgorithm, String signatureAlgorithm, String devicePushId) {
		credentialData = new AppCredentialData(publicKey, deviceId, deviceOs, keyAlgorithm, signatureAlgorithm, devicePushId);
	}

	public static AppCredentialModel createFromCredentialModel(CredentialModel credentialModel) {
		try {
			AppCredentialData credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(), AppCredentialData.class);

			AppCredentialModel appCredentialModel = new AppCredentialModel(credentialData);
			appCredentialModel.setUserLabel(credentialModel.getUserLabel());
			appCredentialModel.setCreatedDate(credentialModel.getCreatedDate());
			appCredentialModel.setType(TYPE);
			appCredentialModel.setId(credentialModel.getId());
			appCredentialModel.setCredentialData(credentialModel.getCredentialData());
			appCredentialModel.setUserLabel(credentialData.getDeviceOs());
			return appCredentialModel;
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	public static AppCredentialModel createAppCredential(String publicKey, String deviceId, String deviceOs, String keyAlgorithm, String signatureAlgorithm, String devicePushId) {
		AppCredentialModel appCredentialModel = new AppCredentialModel(publicKey, deviceId, deviceOs, keyAlgorithm, signatureAlgorithm, devicePushId);
		appCredentialModel.fillCredentialModelFields();
		return appCredentialModel;
	}

	private void fillCredentialModelFields() {
		try {
			setCredentialData(JsonSerialization.writeValueAsString(credentialData));
			setType(TYPE);
			setCreatedDate(Time.currentTimeMillis());
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	public AppCredentialData getAppCredentialData() {
		return credentialData;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/dto/ChallengeConverter.java
================
package netzbegruenung.keycloak.app.dto;

import netzbegruenung.keycloak.app.jpa.Challenge;
import org.keycloak.models.KeycloakSession;
import org.keycloak.services.util.ResolveRelative;

public class ChallengeConverter {
	public static ChallengeDto getChallengeDto(Challenge challenge, KeycloakSession session) {
		return new ChallengeDto(
			challenge.getUser().getUsername(),
			challenge.getUser().getFirstName(),
			challenge.getUser().getLastName(),
			challenge.getTargetUrl(),
			challenge.getSecret(),
			challenge.getUpdatedTimestamp(),
			challenge.getIpAddress(),
			challenge.getDevice(),
			challenge.getBrowser(),
			challenge.getOs(),
			challenge.getOsVersion(),
			// replaced broken property resolver intentionally for something simpler
			// https://github.com/keycloak/keycloak/pull/36472
			challenge.getClient().getName().equals("${client_account-console}") ? "Accountkonsole" : challenge.getClient().getName(),
			ResolveRelative.resolveRelativeUri(session, challenge.getClient().getRootUrl(), challenge.getClient().getBaseUrl())
		);
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/dto/ChallengeDto.java
================
package netzbegruenung.keycloak.app.dto;

import java.io.Serializable;
import java.util.Objects;

/**
 * A DTO for the {@link netzbegruenung.keycloak.app.jpa.Challenge} entity
 */
public class ChallengeDto implements Serializable {
	private final String userName;
	private final String userFirstName;
	private final String userLastName;
	private final String targetUrl;
	private final String codeChallenge;
	private final Long updatedTimestamp;
	private final String ipAddress;
	private final String device;
	private final String browser;
	private final String os;
	private final String osVersion;
	private final String clientName;
	private final String clientUrl;

	public ChallengeDto(String userName, String userFirstName, String userLastName, String targetUrl, String codeChallenge, Long updatedTimestamp, String ipAddress, String device, String browser, String os, String osVersion, String clientName, String clientUrl) {
		this.userName = userName;
		this.userFirstName = userFirstName;
		this.userLastName = userLastName;
		this.targetUrl = targetUrl;
		this.codeChallenge = codeChallenge;
		this.updatedTimestamp = updatedTimestamp;
		this.ipAddress = ipAddress;
		this.device = device;
		this.browser = browser;
		this.os = os;
		this.osVersion = osVersion;
		this.clientName = clientName;
		this.clientUrl = clientUrl;
	}

	public String getUserName() {
		return userName;
	}

	public String getUserFirstName() {
		return userFirstName;
	}

	public String getUserLastName() {
		return userLastName;
	}

	public String getTargetUrl() {
		return targetUrl;
	}

	public String getCodeChallenge() {
		return codeChallenge;
	}

	public Long getUpdatedTimestamp() {
		return updatedTimestamp;
	}

	public String getIpAddress() {
		return ipAddress;
	}

	public String getDevice() {
		return device;
	}

	public String getBrowser() {
		return browser;
	}

	public String getOs() {
		return os;
	}

	public String getOsVersion() {
		return osVersion;
	}

	public String getClientName() {
		return clientName;
	}

	public String getClientUrl() {
		return clientUrl;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		ChallengeDto entity = (ChallengeDto) o;
		return Objects.equals(this.userName, entity.userName) &&
			Objects.equals(this.userFirstName, entity.userFirstName) &&
			Objects.equals(this.userLastName, entity.userLastName) &&
			Objects.equals(this.targetUrl, entity.targetUrl) &&
			Objects.equals(this.codeChallenge, entity.codeChallenge) &&
			Objects.equals(this.updatedTimestamp, entity.updatedTimestamp) &&
			Objects.equals(this.ipAddress, entity.ipAddress) &&
			Objects.equals(this.device, entity.device) &&
			Objects.equals(this.browser, entity.browser) &&
			Objects.equals(this.os, entity.os) &&
			Objects.equals(this.osVersion, entity.osVersion) &&
			Objects.equals(this.clientName, entity.clientName) &&
			Objects.equals(this.clientUrl, entity.clientUrl);
	}

	@Override
	public int hashCode() {
		return Objects.hash(userName, userFirstName, userLastName, targetUrl, codeChallenge, updatedTimestamp, ipAddress, device, browser, os, osVersion, clientName, clientUrl);
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/jpa/Challenge.java
================
package netzbegruenung.keycloak.app.jpa;

import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;
import org.keycloak.models.jpa.entities.ClientEntity;
import org.keycloak.models.jpa.entities.RealmEntity;
import org.keycloak.models.jpa.entities.UserEntity;

import jakarta.persistence.*;
import java.util.UUID;

@Entity
@Table(name = "APP_AUTH_CHALLENGE", indexes = {
	@Index(name = "idx_challenge_realm_id", columnList = "realm_id, device_id")
}, uniqueConstraints = {
	@UniqueConstraint(name = "uc_challenge_realm_id", columnNames = {"realm_id", "device_id"})
})
@NamedQueries({
	@NamedQuery(name = "Challenge.findByRealmAndDeviceId", query = "select c from Challenge c where c.realm = :realm and c.deviceId = :deviceId"),
	@NamedQuery(name = "Challenge.deleteByRealmAndDeviceId", query = "delete from Challenge c where c.realm = :realm and c.deviceId = :deviceId")
})
public class Challenge {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "id", nullable = false)
	private UUID id;

	@ManyToOne(optional = false)
	@JoinColumn(name = "realm_id", nullable = false)
	@OnDelete(action = OnDeleteAction.CASCADE)
	private RealmEntity realm;

	@ManyToOne(optional = false)
	@JoinColumn(name = "user_id", nullable = false)
	@OnDelete(action = OnDeleteAction.CASCADE)
	private UserEntity user;

	@ManyToOne(optional = false)
	@JoinColumn(name = "client_id", nullable = false)
	@OnDelete(action = OnDeleteAction.CASCADE)
	private ClientEntity client;

	@Column(name = "target_url", nullable = false, length = 1023)
	private String targetUrl;

	@Column(name = "device_id", nullable = false)
	private String deviceId;

	@Column(name = "secret", nullable = false, length = 1023)
	private String secret;

	@Column(name = "updated_timestamp", nullable = false)
	private Long updatedTimestamp;

	@Column(name = "ip_address", length = 63)
	private String ipAddress;

	@Column(name = "device", length = 63)
	private String device;

	@Column(name = "browser", length = 63)
	private String browser;

	@Column(name = "os", length = 63)
	private String os;

	@Column(name = "os_version", length = 63)
	private String osVersion;

	@Column(name = "expires_at", nullable = false)
	private Long expiresAt;

	public UUID getId() {
		return id;
	}

	public RealmEntity getRealm() {
		return realm;
	}

	public void setRealm(RealmEntity realm) {
		this.realm = realm;
	}

	public UserEntity getUser() {
		return user;
	}

	public void setUser(UserEntity user) {
		this.user = user;
	}

	public String getTargetUrl() {
		return targetUrl;
	}

	public void setTargetUrl(String targetUrl) {
		this.targetUrl = targetUrl;
	}

	public String getDeviceId() {
		return deviceId;
	}

	public void setDeviceId(String deviceId) {
		this.deviceId = deviceId;
	}

	public String getSecret() {
		return secret;
	}

	public void setSecret(String secret) {
		this.secret = secret;
	}

	public Long getUpdatedTimestamp() {
		return updatedTimestamp;
	}

	public void setUpdatedTimestamp(Long updatedTimestamp) {
		this.updatedTimestamp = updatedTimestamp;
	}

	public String getIpAddress() {
		return ipAddress;
	}

	public void setIpAddress(String ipAddress) {
		this.ipAddress = ipAddress;
	}

	public String getDevice() {
		return device;
	}

	public void setDevice(String device) {
		this.device = device;
	}

	public String getBrowser() {
		return browser;
	}

	public void setBrowser(String browser) {
		this.browser = browser;
	}

	public String getOs() {
		return os;
	}

	public void setOs(String os) {
		this.os = os;
	}

	public String getOsVersion() {
		return osVersion;
	}

	public void setOsVersion(String osVersion) {
		this.osVersion = osVersion;
	}

	public ClientEntity getClient() {
		return client;
	}

	public void setClient(ClientEntity client) {
		this.client = client;
	}

	public Long getExpiresAt() {
		return expiresAt;
	}

	public void setExpiresAt(Long expiresAt) {
		this.expiresAt = expiresAt;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/jpa/ChallengeJpaEntityProvider.java
================
package netzbegruenung.keycloak.app.jpa;

import org.keycloak.connections.jpa.entityprovider.JpaEntityProvider;

import java.util.Collections;
import java.util.List;

public class ChallengeJpaEntityProvider implements JpaEntityProvider {
	@Override
	public List<Class<?>> getEntities() {
		return Collections.singletonList(Challenge.class);
	}

	@Override
	public String getChangelogLocation() {
		return "META-INF/challenge-changelog.xml";
	}

	@Override
	public String getFactoryId() {
		return ChallengeJpaEntityProviderFactory.ID;
	}

	@Override
	public void close() {

	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/jpa/ChallengeJpaEntityProviderFactory.java
================
package netzbegruenung.keycloak.app.jpa;

import org.keycloak.Config;
import org.keycloak.connections.jpa.entityprovider.JpaEntityProvider;
import org.keycloak.connections.jpa.entityprovider.JpaEntityProviderFactory;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;

public class ChallengeJpaEntityProviderFactory implements JpaEntityProviderFactory {

	protected static final String ID = "challenge-entity-provider";

	@Override
	public JpaEntityProvider create(KeycloakSession keycloakSession) {
		return new ChallengeJpaEntityProvider();
	}

	@Override
	public void init(Config.Scope scope) {

	}

	@Override
	public void postInit(KeycloakSessionFactory keycloakSessionFactory) {

	}

	@Override
	public void close() {

	}

	@Override
	public String getId() {
		return ID;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/messaging/FcmMessagingService.java
================
package netzbegruenung.keycloak.app.messaging;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.firebase.messaging.FirebaseMessaging;
import com.google.firebase.messaging.FirebaseMessagingException;
import com.google.firebase.messaging.Message;
import netzbegruenung.keycloak.app.dto.ChallengeDto;
import org.jboss.logging.Logger;

import java.net.URI;
import java.util.Map;

public class FcmMessagingService implements MessagingService {

	private final Logger logger = Logger.getLogger(FcmMessagingService.class);

	private final ObjectMapper objectMapper = new ObjectMapper();

	public void send(String devicePushId, ChallengeDto challenge) {
		if (devicePushId == null) {
			logger.infof("Skip sending firebase notification: missing device push ID user [%s]", challenge.getUserName());
			return;
		}
		Map<String, String> challengeMap = objectMapper.convertValue(challenge, Map.class);
		Message message = Message.builder()
			.putAllData(challengeMap)
			.setToken(devicePushId)
			.build();

		try {
			String response = FirebaseMessaging.getInstance().send(message);
			logger.debugv("Successfully sent message: ", response);
		} catch (FirebaseMessagingException e) {
			logger.error("Failed to send firebase app notification", e);
		}
	}

}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/messaging/MessagingService.java
================
package netzbegruenung.keycloak.app.messaging;

import netzbegruenung.keycloak.app.dto.ChallengeDto;

public interface MessagingService {

	void send(String devicePushId, ChallengeDto challenge);
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/messaging/MessagingServiceFactory.java
================
package netzbegruenung.keycloak.app.messaging;

import org.jboss.logging.Logger;

import java.util.Map;

public class MessagingServiceFactory {

	private static final Logger logger = Logger.getLogger(MessagingServiceFactory.class);

	public static MessagingService get(Map<String, String> config) {
		if (Boolean.parseBoolean(config.getOrDefault("simulation", "false"))) {
			return (devicePushId, challengeDto) ->
				logger.infov(
					"Simulation mode - send authentication request: action Url {0}, challenge {1}, device push ID {2}, user {3}",
					challengeDto.getTargetUrl(),
					challengeDto.getCodeChallenge(),
					devicePushId,
					challengeDto.getUserName()
				);
		} else {
			return new FcmMessagingService();
		}
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/rest/ChallengeResourceProvider.java
================
package netzbegruenung.keycloak.app.rest;

import static org.keycloak.models.utils.KeycloakModelUtils.runJobInTransaction;

import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.NonUniqueResultException;
import jakarta.persistence.TypedQuery;
import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Root;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.HeaderParam;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.container.AsyncResponse;
import jakarta.ws.rs.container.Suspended;
import jakarta.ws.rs.core.GenericType;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import netzbegruenung.keycloak.app.AuthenticationUtil;
import netzbegruenung.keycloak.app.credentials.AppCredentialModel;
import netzbegruenung.keycloak.app.dto.ChallengeConverter;
import netzbegruenung.keycloak.app.dto.ChallengeDto;
import netzbegruenung.keycloak.app.jpa.Challenge;
import org.jboss.logging.Logger;
import org.keycloak.common.util.Base64;
import org.keycloak.common.util.Time;
import org.keycloak.connections.jpa.JpaConnectionProvider;
import org.keycloak.credential.CredentialModel;
import org.keycloak.models.*;
import org.keycloak.models.jpa.entities.CredentialEntity;
import org.keycloak.models.jpa.entities.RealmEntity;
import org.keycloak.services.resource.RealmResourceProvider;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;

public class ChallengeResourceProvider implements RealmResourceProvider {

	private final KeycloakSession session;

	private final EntityManager em;

	private final Logger logger = Logger.getLogger(ChallengeResourceProvider.class);

	private final KeycloakSessionFactory sessionFactory;

	private final static ConcurrentHashMap<String, DeviceConnection> listeners = new ConcurrentHashMap<>();

	public final static ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1);

	public final static String CHALLENGE_REJECTED = "challenge_rejected";

	public final static String CHALLENGE_EXPIRED = "challenge_expired";

	public final static String INTERNAL_ERROR = "internal_error";

	public final static String NO_CREDENTIAL = "no_credential";

	private final static long EXPIRATION_TIME = 120;

	private final static long RESPONSE_TIMEOUT = 60;

	public ChallengeResourceProvider(KeycloakSession session) {
		this.session = session;
		this.em = session.getProvider(JpaConnectionProvider.class).getEntityManager();
		this.sessionFactory = session.getKeycloakSessionFactory();
	}

	@Override
	public Object getResource() {
		return this;
	}

	@Override
	public void close() {

	}

	@GET
	@Produces(MediaType.APPLICATION_JSON)
	public Response getChallenges(@HeaderParam("Signature") List<String> signatureHeader) {
		Map<String, String> signatureMap = AuthenticationUtil.getSignatureMap(signatureHeader);
		return getChallengesResponse(signatureMap);
	}

	private Response getChallengesResponse(Map<String, String> signatureMap) {
		if (signatureMap == null) {
			return Response
				.status(Response.Status.BAD_REQUEST)
				.entity(new Message(CHALLENGE_REJECTED, "Missing, incomplete or invalid signature header"))
				.build();
		}

		String deviceId = signatureMap.get("keyId");

		CriteriaBuilder cb = em.getCriteriaBuilder();
		CriteriaQuery<CredentialEntity> criteria = cb.createQuery(CredentialEntity.class);
		Root<CredentialEntity> root = criteria.from(CredentialEntity.class);
		criteria.where(
			cb.equal(root.get("type"), AppCredentialModel.TYPE),
			cb.like(root.get("credentialData"), String.format("%%\"deviceId\":\"%s\"%%", deviceId))
		);

		TypedQuery<CredentialEntity> criteriaQuery = em.createQuery(criteria);
		CredentialEntity credentialEntity;

		try {
			credentialEntity = criteriaQuery.getSingleResult();
		} catch (NoResultException e) {
			return Response
				.status(Response.Status.CONFLICT)
				.entity(new Message(NO_CREDENTIAL, "App credential does not exist"))
				.build();
		} catch (NonUniqueResultException e) {
			logger.error("Failed to get app credentials: duplicate credentials detected for device ID: " + deviceId, e);
			return Response
				.status(Response.Status.INTERNAL_SERVER_ERROR)
				.entity(new Message(INTERNAL_ERROR, "Internal server error"))
				.build();
		}

		AppCredentialModel appCredential = AppCredentialModel.createFromCredentialModel(toModel(credentialEntity));
		UserModel user = session.users().getUserById(session.getContext().getRealm(), credentialEntity.getUser().getId());

		Map<String, String> signatureStringMap = new LinkedHashMap<>();
		signatureStringMap.put("created", signatureMap.get("created"));

		boolean verified = AuthenticationUtil.verifyChallenge(
			user,
			appCredential.getAppCredentialData(),
			AuthenticationUtil.getSignatureString(signatureStringMap),
			signatureMap.get("signature")
		);

		if (!verified) {
			return Response
				.status(Response.Status.FORBIDDEN)
				.entity(new Message(CHALLENGE_REJECTED, "Invalid signature"))
				.build();
		}

		TypedQuery<Challenge> query = em.createNamedQuery("Challenge.findByRealmAndDeviceId", Challenge.class);
		RealmEntity realm = em.getReference(RealmEntity.class, session.getContext().getRealm().getId());
		query.setParameter("realm", realm);
		query.setParameter("deviceId", deviceId);
		Challenge challenge;

		try {
			challenge = query.getSingleResult();

		} catch (NoResultException e) {
			return Response
				.status(Response.Status.OK)
				.entity(Collections.emptyList())
				.build();

		} catch (NonUniqueResultException e) {
			logger.error("Failed to get app authenticator challenge: duplicate challenge detected for device ID: " + deviceId, e);
			return Response
				.status(Response.Status.INTERNAL_SERVER_ERROR)
				.entity(new Message(INTERNAL_ERROR, "Internal server error"))
				.build();

		} catch (Throwable e) {
			logger.error("Failed to get app authenticator challenge for device ID: " + deviceId, e);
			return Response
				.status(Response.Status.INTERNAL_SERVER_ERROR)
				.entity(new Message(INTERNAL_ERROR, "Internal server error"))
				.build();
		}

		if (Time.currentTime() > challenge.getExpiresAt()
			|| Long.parseLong(signatureMap.get("created")) < challenge.getUpdatedTimestamp() - 1000) {
			return Response
				.status(Response.Status.FORBIDDEN)
				.entity(new Message(CHALLENGE_EXPIRED, "Challenge expired"))
				.build();
		}

		return Response
			.ok(List.of(ChallengeConverter.getChallengeDto(challenge, session)))
			.build();
	}

	CredentialModel toModel(CredentialEntity entity) {
		CredentialModel model = new CredentialModel();
		model.setId(entity.getId());
		model.setType(entity.getType());
		model.setCreatedDate(entity.getCreatedDate());
		model.setUserLabel(entity.getUserLabel());

		// Backwards compatibility - users from previous version still have "salt" in the DB filled.
		// We migrate it to new secretData format on-the-fly
		if (entity.getSalt() != null) {
			String newSecretData = entity.getSecretData().replace("__SALT__", Base64.encodeBytes(entity.getSalt()));
			entity.setSecretData(newSecretData);
			entity.setSalt(null);
		}

		model.setSecretData(entity.getSecretData());
		model.setCredentialData(entity.getCredentialData());
		return model;
	}

	@GET
	@Path("async")
	@Produces(MediaType.APPLICATION_JSON)
	public void getChallengesAsync(@HeaderParam("Signature") List<String> signatureHeader, @Suspended AsyncResponse asyncResponse) {
		Map<String, String> signatureMap = AuthenticationUtil.getSignatureMap(signatureHeader);
		Response response = getChallengesResponse(signatureMap);

		if (!response.getStatusInfo().getFamily().equals(Response.Status.Family.SUCCESSFUL)) {
			if (response.getStatus() != 403) {
				asyncResponse.resume(response);
				return;
			}
			Message message = response.readEntity(Message.class);
			if (!message.error().equals(CHALLENGE_EXPIRED)) {
				asyncResponse.resume(response);
				return;
			}
		} else {
			List<ChallengeDto> challenges = response.readEntity(new GenericType<>() {
			});
			if (!challenges.isEmpty()) {
				asyncResponse.resume(response);
				return;
			}
		}


		String deviceId = signatureMap.get("keyId");
		asyncResponse.setTimeout(RESPONSE_TIMEOUT, TimeUnit.SECONDS);
		ScheduledFuture<?> evictionJob = scheduler.schedule(() -> {
			listeners.remove(deviceId);
		}, EXPIRATION_TIME, TimeUnit.SECONDS);

		DeviceConnection existingConnection = listeners.get(deviceId);
		if (existingConnection != null) {
			existingConnection.evictionJob().cancel(false);
			existingConnection.asyncResponse().cancel();
		}

		listeners.put(deviceId, new DeviceConnection(asyncResponse, evictionJob));
	}

	public void notifyListeners(Challenge challenge, RealmModel realm) {
		String deviceId = challenge.getDeviceId();
		DeviceConnection deviceConnection = listeners.get(deviceId);

		if (deviceConnection != null) {
			AsyncResponse asyncResponse = deviceConnection.asyncResponse();
			if (asyncResponse != null) {
				runJobInTransaction(sessionFactory, session -> {
					KeycloakContext context = session.getContext();

					context.setRealm(realm);
					asyncResponse.resume(Response
						.ok(List.of(ChallengeConverter.getChallengeDto(challenge, session)))
						.build()
					);
				});
			}
		}
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/rest/ChallengeResourceProviderFactory.java
================
package netzbegruenung.keycloak.app.rest;

import org.keycloak.Config;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;
import org.keycloak.services.resource.RealmResourceProvider;
import org.keycloak.services.resource.RealmResourceProviderFactory;

public class ChallengeResourceProviderFactory implements RealmResourceProviderFactory {

	public static final String ID = "challenges";

	@Override
	public RealmResourceProvider create(KeycloakSession session) {
		return new ChallengeResourceProvider(session);
	}

	@Override
	public void init(Config.Scope scope) {

	}

	@Override
	public void postInit(KeycloakSessionFactory keycloakSessionFactory) {
		ChallengeResourceProvider.scheduler.setRemoveOnCancelPolicy(true);
	}

	@Override
	public void close() {

	}

	@Override
	public String getId() {
		return ID;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/rest/DeviceConnection.java
================
package netzbegruenung.keycloak.app.rest;

import jakarta.ws.rs.container.AsyncResponse;

import java.util.concurrent.ScheduledFuture;

public record DeviceConnection(AsyncResponse asyncResponse, ScheduledFuture<?> evictionJob) {
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/rest/Message.java
================
package netzbegruenung.keycloak.app.rest;

public record Message(String error, String message) {


}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/rest/StatusResourceProvider.java
================
package netzbegruenung.keycloak.app.rest;

import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.sse.Sse;
import jakarta.ws.rs.sse.SseEventSink;
import org.jboss.logging.Logger;
import org.keycloak.models.*;
import org.keycloak.services.managers.AuthenticationSessionManager;
import org.keycloak.services.resource.RealmResourceProvider;
import org.keycloak.sessions.AuthenticationSessionModel;

public class StatusResourceProvider implements RealmResourceProvider {

	private final KeycloakSession session;

	private final Logger logger = Logger.getLogger(StatusResourceProvider.class);

	public final static String READY = "appAuthReady";

	private final static String UNAUTHORIZED = "Unauthorized";

	public StatusResourceProvider(KeycloakSession session) {
		this.session = session;
	}

	@Override
	public Object getResource() {
		return this;
	}

	@Override
	public void close() {

	}

	@GET
	@Produces(MediaType.SERVER_SENT_EVENTS)
	public void getAppAuthStatus(@Context SseEventSink sseEventSink,
							  @Context Sse sse,
							  @QueryParam(Constants.CLIENT_ID) String clientId,
							  @QueryParam(Constants.TAB_ID) String tabId) throws InterruptedException {
		RealmModel realm = session.getContext().getRealm();
		ClientModel client = null;
		if (clientId != null)
			client = realm.getClientByClientId(clientId);


		AuthenticationSessionManager authSessionManager = new AuthenticationSessionManager(session);
		AuthenticationSessionModel authSession;
		int counter = 0;

		while (true) {
			authSession = authSessionManager.getCurrentAuthenticationSession(realm, client, tabId);

			if (authSession == null)
				throw new NotAuthorizedException(UNAUTHORIZED);

			UserModel user = authSession.getAuthenticatedUser();

			if (authSession.getAuthNote(READY) != null) {
				authSession.setAuthNote(READY, null);

				try {
					sseEventSink.send(sse.newEvent( "ready"))
						.toCompletableFuture()
						.get();
				} catch (Exception e) {
					logger.errorf(e, "Failed to send authentication status for user %s", user == null ? "null" : user.getId());
				} finally {
					break;
				}
			}

			if (counter++ % 4 == 0) {
				try {
					sseEventSink.send(sse.newEvent( "keep-alive"))
						.toCompletableFuture()
						.get();
				} catch (Exception e) {
					// should be debug
					logger.infof(e, "Failed to send keep alive message for user %s", user == null ? "null" : user.getId());
					break;
				}
			}

			Thread.sleep(1000);
		}

		sseEventSink.close();
	}

}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/rest/StatusResourceProviderFactory.java
================
package netzbegruenung.keycloak.app.rest;

import org.keycloak.Config;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;
import org.keycloak.services.resource.RealmResourceProvider;
import org.keycloak.services.resource.RealmResourceProviderFactory;

public class StatusResourceProviderFactory implements RealmResourceProviderFactory {
	public static final String ID = "app-auth-status";

	@Override
	public RealmResourceProvider create(KeycloakSession session) {
		return new StatusResourceProvider(session);
	}

	@Override
	public void init(Config.Scope scope) {

	}

	@Override
	public void postInit(KeycloakSessionFactory keycloakSessionFactory) {

	}

	@Override
	public void close() {

	}

	@Override
	public String getId() {
		return ID;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/AppAuthenticator.java
================
package netzbegruenung.keycloak.app;

import jakarta.ws.rs.core.UriBuilder;
import netzbegruenung.keycloak.app.actiontoken.AppAuthActionToken;
import netzbegruenung.keycloak.app.credentials.AppCredentialData;
import netzbegruenung.keycloak.app.dto.ChallengeConverter;
import netzbegruenung.keycloak.app.jpa.Challenge;
import netzbegruenung.keycloak.app.messaging.MessagingServiceFactory;
import netzbegruenung.keycloak.app.rest.ChallengeResourceProvider;
import netzbegruenung.keycloak.app.rest.StatusResourceProviderFactory;
import org.jboss.logging.Logger;
import org.keycloak.authentication.*;
import org.keycloak.common.util.Base64;
import org.keycloak.common.util.SecretGenerator;
import org.keycloak.common.util.Time;
import org.keycloak.connections.jpa.JpaConnectionProvider;
import org.keycloak.credential.CredentialModel;
import org.keycloak.credential.CredentialProvider;
import org.keycloak.device.DeviceRepresentationProvider;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserModel;
import org.keycloak.models.jpa.entities.ClientEntity;
import org.keycloak.models.jpa.entities.RealmEntity;
import org.keycloak.models.jpa.entities.UserEntity;
import org.keycloak.representations.account.DeviceRepresentation;
import org.keycloak.services.Urls;
import org.keycloak.services.resource.RealmResourceProvider;
import org.keycloak.sessions.AuthenticationSessionCompoundId;
import org.keycloak.sessions.AuthenticationSessionModel;
import org.keycloak.util.JsonSerialization;

import javax.crypto.Cipher;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import jakarta.persistence.NonUniqueResultException;
import jakarta.persistence.TypedQuery;
import jakarta.ws.rs.core.Response;
import java.io.IOException;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.security.*;
import java.security.spec.EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.*;

public class AppAuthenticator implements Authenticator, CredentialValidator<AppCredentialProvider> {
	private final Logger logger = Logger.getLogger(AppAuthenticator.class);

	private static final int SECRET_LENGTH = 512 - 11;

	public static final String APP_AUTH_GRANTED_NOTE = "appAuthGranted";

	@Override
	public void authenticate(AuthenticationFlowContext context) {
		CredentialModel appCredentialModel;
		appCredentialModel = getSelectedAppCredential(context);
		if (appCredentialModel == null) return;

		createAppChallenge(context, appCredentialModel);
	}

	private void createAppChallenge(AuthenticationFlowContext context, CredentialModel appCredentialModel) {
		AppCredentialData appCredentialData;
		try {
			appCredentialData = JsonSerialization.readValue(appCredentialModel.getCredentialData(), AppCredentialData.class);
		} catch (IOException e) {
			logger.error("App credential deserialization failed", e);
			Response challenge = context.form()
				.setError("appAuthCriticalError")
				.createForm("app-login.ftl");
			context.challenge(challenge);
			return;
		}
		String secret = SecretGenerator.getInstance().randomString(SECRET_LENGTH, SecretGenerator.ALPHANUM);
		AuthenticationSessionModel authSession = context.getAuthenticationSession();

		Map<String, String> authConfig = context.getAuthenticatorConfig() != null ? context.getAuthenticatorConfig().getConfig() : Collections.emptyMap();

		long tokenExpiration = 60;

		try {
			tokenExpiration = Long.parseLong(authConfig.getOrDefault("appAuthActionTokenExpiration", "60"));
		} catch (NumberFormatException e) {
			logger.warn("Invalid config for app auth action token expiration, falling back to default");
		}

		long expiresAt = Time.currentTime() + tokenExpiration;
		AppAuthActionToken token = new AppAuthActionToken(
			context.getUser().getId(),
			(int) expiresAt,
			AuthenticationSessionCompoundId.fromAuthSession(authSession).getEncodedId(),
			authSession.getClient().getClientId()
		);

		UriBuilder builder = Urls.actionTokenBuilder(
			context.getUriInfo().getBaseUri(),
			token.serialize(context.getSession(), context.getRealm(), context.getUriInfo()),
			authSession.getClient().getClientId(),
			authSession.getTabId(),
			AuthenticationProcessor.getClientData(context.getSession(), authSession)
		);

		DeviceRepresentation deviceRepresentation = context
			.getSession()
			.getProvider(DeviceRepresentationProvider.class)
			.deviceRepresentation();

		try {
			Challenge challenge = upsertAppChallengeEntity(
				context,
				builder.build(context.getRealm().getName()),
				deviceRepresentation,
				appCredentialData.getDeviceId(),
				secret,
				expiresAt
			);

			ChallengeResourceProvider challengeProvider = (ChallengeResourceProvider) context
				.getSession()
				.getProvider(RealmResourceProvider.class, "challenges");

			challengeProvider.notifyListeners(challenge, context.getRealm());

			authSession.setAuthNote("credentialId", appCredentialModel.getId());
			authSession.setAuthNote("secret", secret);
			authSession.setAuthNote("timestamp", String.valueOf(challenge.getUpdatedTimestamp()));

			if (Boolean.parseBoolean(authConfig.getOrDefault("simulation", "false"))) {
				Map<String, String> signatureStringMap = new LinkedHashMap<>();
				signatureStringMap.put("created", authSession.getAuthNote("timestamp"));
				signatureStringMap.put("secret", authSession.getAuthNote("secret"));
				signatureStringMap.put("granted", String.valueOf(true));

				logger.infov("App authentication signature string\n\n{0}\n", AuthenticationUtil.getSignatureString(signatureStringMap));
			}

			MessagingServiceFactory.get(authConfig).send(appCredentialData.getDevicePushId(), ChallengeConverter.getChallengeDto(challenge, context.getSession()));

			Response response = context.form()
				.setAttribute("appAuthStatusUrl", String.format(
					"/realms/%s/%s?%s",
					context.getRealm().getName(),
					StatusResourceProviderFactory.ID,
					context.getRefreshExecutionUrl().getQuery()
				))
				.createForm("app-login.ftl");
			context.challenge(response);
		} catch (NonUniqueResultException e) {
			logger.error("App authentication init failed", e);
			Response challenge = context.form()
				.setError("appAuthCriticalError")
				.createForm("app-login.ftl");
			context.challenge(challenge);
		}
	}

	private Challenge upsertAppChallengeEntity(AuthenticationFlowContext context, URI actionTokenUri, DeviceRepresentation deviceRepresentation, String deviceId, String encryptedSecret, long expiresAt) throws NonUniqueResultException {
		Challenge challenge;
		EntityManager em = getEntityManager(context.getSession());
		RealmEntity realm = em.getReference(RealmEntity.class, context.getRealm().getId());
		UserEntity user = em.getReference(UserEntity.class, context.getUser().getId());
		ClientEntity client = em.getReference(ClientEntity.class, context.getAuthenticationSession().getClient().getId());

		try {
			TypedQuery<Challenge> query = em.createNamedQuery("Challenge.findByRealmAndDeviceId", Challenge.class);
			query.setParameter("realm", realm);
			query.setParameter("deviceId", deviceId);
			challenge = query.getSingleResult();

		} catch (NoResultException e) {
			challenge = new Challenge();
			challenge.setRealm(realm);
			challenge.setDeviceId(deviceId);

		} catch (NonUniqueResultException e) {
			logger.errorf(
				e,
				"Failed to add app authenticator challenge for user [%s] device ID [%s]: duplicate challenge detected",
				context.getUser(),
				deviceId
			);
			throw e;
		}

		challenge.setUser(user);
		challenge.setSecret(encryptedSecret);
		challenge.setTargetUrl(actionTokenUri.toString());
		challenge.setDevice(deviceRepresentation.getDevice());
		challenge.setBrowser(deviceRepresentation.getBrowser());
		challenge.setOs(deviceRepresentation.getOs());
		challenge.setOsVersion(deviceRepresentation.getOsVersion());
		challenge.setIpAddress(deviceRepresentation.getIpAddress());
		challenge.setUpdatedTimestamp(Time.currentTimeMillis());
		challenge.setClient(client);
		challenge.setExpiresAt(expiresAt);

		em.persist(challenge);
		em.flush();

		return challenge;
	}

	private EntityManager getEntityManager(KeycloakSession session) {
		return session.getProvider(JpaConnectionProvider.class).getEntityManager();
	}

	private CredentialModel getSelectedAppCredential(AuthenticationFlowContext context) {
		CredentialModel appCredentialModel;
		AuthenticationSessionModel authSession = context.getAuthenticationSession();
		String credentialId = authSession.getAuthNote("selectedCredentialId");
		authSession.clearAuthNotes();

		if (credentialId == null) {
			List<CredentialModel> appCredentialModels = getCredentialProvider(context.getSession())
				.getAllCredentials(context.getUser());
			if (appCredentialModels.size() > 1) {
				authSession.setAuthNote("appCredentialSelection", "true");
				Response challenge = context.form()
					.setAttribute("appCredentials", appCredentialModels)
					.createForm("app-auth-selection.ftl");
				context.challenge(challenge);
				return null;
			}
			appCredentialModel = appCredentialModels.get(0);
		} else {
			appCredentialModel = getCredentialProvider(context.getSession())
				.getCredentialModel(context.getUser(), credentialId);
		}
		return appCredentialModel;
	}

	private String encryptSecretMessage(AppCredentialData credentialData, String secret) throws GeneralSecurityException, IOException {
		KeyFactory keyFactory = KeyFactory.getInstance(credentialData.getKeyAlgorithm());
		byte[] publicKeyBytes = Base64.decode(credentialData.getPublicKey());
		EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);
		PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);

		Cipher encryptCipher = Cipher.getInstance(credentialData.getKeyAlgorithm());
		encryptCipher.init(Cipher.ENCRYPT_MODE, publicKey);
		byte[] encryptedMessage = encryptCipher.doFinal(secret.getBytes(StandardCharsets.UTF_8));

		return Base64.encodeBytes(encryptedMessage);
	}

	@Override
	public void action(AuthenticationFlowContext context) {
		final AuthenticationSessionModel authSession = context.getAuthenticationSession();

		if (Boolean.parseBoolean(authSession.getAuthNote("appCredentialSelection"))) {
			authSession.setAuthNote(
				"selectedCredentialId",
				context.getHttpRequest().getDecodedFormParameters().getFirst("app-credential")
			);
			CredentialModel appCredentialModel = getSelectedAppCredential(context);
			createAppChallenge(context, appCredentialModel);
			return;
		}

		final String granted = authSession.getAuthNote(APP_AUTH_GRANTED_NOTE);
		String appAuthStatusUrl = String.format(
			"/realms/%s/%s?%s",
			context.getRealm().getName(),
			StatusResourceProviderFactory.ID,
			context.getRefreshExecutionUrl().getQuery()
		);

		if (granted == null) {
			Response challenge = context.form()
				.setAttribute("appAuthStatusUrl", appAuthStatusUrl)
				.setError("appAuthError")
				.createForm("app-login.ftl");
			context.challenge(challenge);
			return;
		}
		if (!Boolean.parseBoolean(granted)) {
			Response challenge = context.form()
				.setError("appAuthRejected")
				.createForm("app-login.ftl");
			context.challenge(challenge);
			return;
		}
		context.success();
	}

	@Override
	public boolean requiresUser() {
		return true;
	}

	@Override
	public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
		return getCredentialProvider(session).isConfiguredFor(realm, user, getType(session));
	}

	@Override
	public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {
		user.addRequiredAction(AppRequiredAction.PROVIDER_ID);
	}

	@Override
	public void close() {

	}

	@Override
	public AppCredentialProvider getCredentialProvider(KeycloakSession session) {
		return (AppCredentialProvider)session.getProvider(CredentialProvider.class, AppCredentialProviderFactory.PROVIDER_ID);
	}

	@Override
	public List<RequiredActionFactory> getRequiredActions(KeycloakSession session) {
		return Collections.singletonList((AppRequiredActionFactory)session.getKeycloakSessionFactory().getProviderFactory(RequiredActionProvider.class, AppRequiredAction.PROVIDER_ID));
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/AppAuthenticatorFactory.java
================
package netzbegruenung.keycloak.app;

import netzbegruenung.keycloak.app.credentials.AppCredentialModel;
import org.keycloak.Config;
import org.keycloak.authentication.Authenticator;
import org.keycloak.authentication.AuthenticatorFactory;
import org.keycloak.models.AuthenticationExecutionModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;
import org.keycloak.provider.ProviderConfigProperty;

import java.util.Arrays;
import java.util.List;

public class AppAuthenticatorFactory implements AuthenticatorFactory {

	public static final String PROVIDER_ID = "app-authenticator";

	private static final AppAuthenticator SINGLETON = new AppAuthenticator();

	private static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
		AuthenticationExecutionModel.Requirement.REQUIRED,
		AuthenticationExecutionModel.Requirement.ALTERNATIVE,
		AuthenticationExecutionModel.Requirement.DISABLED
	};

	@Override
	public String getDisplayType() {
		return "App Authenticator";
	}

	@Override
	public String getReferenceCategory() {
		return AppCredentialModel.TYPE;
	}

	@Override
	public boolean isConfigurable() {
		return true;
	}

	@Override
	public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
		return REQUIREMENT_CHOICES;
	}

	@Override
	public boolean isUserSetupAllowed() {
		return true;
	}

	@Override
	public String getHelpText() {
		return "Authenticator to grant access by mobile app.";
	}

	@Override
	public List<ProviderConfigProperty> getConfigProperties() {
		ProviderConfigProperty simulationMode = new ProviderConfigProperty(
			"simulation",
			"Simulation Mode",
			"Logs app push notification instead of sending",
			ProviderConfigProperty.BOOLEAN_TYPE,
			false
		);
		ProviderConfigProperty appAuthActionTokenExpiration = new ProviderConfigProperty(
			"appAuthActionTokenExpiration",
			"App Auth Action Token expiration",
			"App Auth Action Token expiration time in seconds",
			ProviderConfigProperty.STRING_TYPE,
			60
		);
		return Arrays.asList(simulationMode, appAuthActionTokenExpiration);
	}

	@Override
	public Authenticator create(KeycloakSession keycloakSession) {
		return SINGLETON;
	}

	@Override
	public void init(Config.Scope scope) {

	}

	@Override
	public void postInit(KeycloakSessionFactory keycloakSessionFactory) {

	}

	@Override
	public void close() {

	}

	@Override
	public String getId() {
		return PROVIDER_ID;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/AppCredentialProvider.java
================
package netzbegruenung.keycloak.app;

import netzbegruenung.keycloak.app.credentials.AppCredentialModel;
import org.jboss.logging.Logger;
import org.keycloak.common.util.Time;
import org.keycloak.credential.*;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserModel;

import java.util.List;
import java.util.stream.Collectors;

public class AppCredentialProvider implements CredentialProvider<AppCredentialModel>, CredentialInputValidator {

	protected final KeycloakSession session;

	public AppCredentialProvider(KeycloakSession session) {
		this.session = session;
	}

	@Override
	public String getType() {
		return AppCredentialModel.TYPE;
	}

	@Override
	public CredentialModel createCredential(RealmModel realm, UserModel user, AppCredentialModel appCredentialModel) {
		if (appCredentialModel.getCredentialData() == null) {
			appCredentialModel.setCreatedDate(Time.currentTimeMillis());
		}
		return user.credentialManager().createStoredCredential(appCredentialModel);
	}

	@Override
	public boolean deleteCredential(RealmModel realm, UserModel user, String credentialId) {
		return user.credentialManager().removeStoredCredentialById(credentialId);
	}

	@Override
	public AppCredentialModel getCredentialFromModel(CredentialModel credentialModel) {
		return AppCredentialModel.createFromCredentialModel(credentialModel);
	}

	@Override
	public CredentialTypeMetadata getCredentialTypeMetadata(CredentialTypeMetadataContext metadataContext) {
		return CredentialTypeMetadata.builder()
			.type(getType())
			.category(CredentialTypeMetadata.Category.TWO_FACTOR)
			.displayName("appAuthDisplayName")
			.helpText("appAuthHelpText")
			.iconCssClass("fa fa-mobile")
			.createAction(AppRequiredAction.PROVIDER_ID)
			.removeable(true)
			.build(session);
	}

	@Override
	public boolean supportsCredentialType(String credentialType) {
		return getType().equals(credentialType);
	}

	@Override
	public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
		if (!supportsCredentialType(credentialType)) {
			return false;
		}
		return user.credentialManager().getStoredCredentialsByTypeStream(credentialType).findAny().isPresent();
	}

	@Override
	public boolean isValid(RealmModel realmModel, UserModel userModel, CredentialInput credentialInput) {
		return false;
	}

	public List<CredentialModel> getAllCredentials(UserModel user) {
		return user.credentialManager().getStoredCredentialsByTypeStream(this.getType()).collect(Collectors.toList());
	}

	public CredentialModel getCredentialModel(UserModel user, String credentialId) {
		return user.credentialManager().getStoredCredentialById(credentialId);
	}

}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/AppCredentialProviderFactory.java
================
package netzbegruenung.keycloak.app;

import org.keycloak.credential.CredentialProvider;
import org.keycloak.credential.CredentialProviderFactory;
import org.keycloak.models.KeycloakSession;

public class AppCredentialProviderFactory implements CredentialProviderFactory<AppCredentialProvider> {
	public static final String PROVIDER_ID = "app-credential";
	@Override
	public AppCredentialProvider create(KeycloakSession keycloakSession) {
		return new AppCredentialProvider(keycloakSession);
	}

	@Override
	public String getId() {
		return PROVIDER_ID;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/AppRequiredAction.java
================
package netzbegruenung.keycloak.app;

import com.google.zxing.BarcodeFormat;
import com.google.zxing.WriterException;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.QRCodeWriter;
import netzbegruenung.keycloak.app.actiontoken.ActionTokenUtil;
import netzbegruenung.keycloak.app.actiontoken.AppSetupActionToken;
import netzbegruenung.keycloak.app.credentials.AppCredentialModel;
import netzbegruenung.keycloak.app.rest.StatusResourceProviderFactory;
import org.jboss.logging.Logger;
import org.keycloak.authentication.CredentialRegistrator;
import org.keycloak.authentication.InitiatedActionSupport;
import org.keycloak.authentication.RequiredActionContext;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.common.util.Base64;
import org.keycloak.models.KeycloakSession;
import org.keycloak.sessions.AuthenticationSessionModel;

import jakarta.ws.rs.core.Response;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URI;

public class AppRequiredAction implements RequiredActionProvider, CredentialRegistrator {

	public static final String PROVIDER_ID = "app-register";

	@Override
	public InitiatedActionSupport initiatedActionSupport() {
		return InitiatedActionSupport.SUPPORTED;
	}

	@Override
	public void evaluateTriggers(RequiredActionContext requiredActionContext) {

	}

	@Override
	public void requiredActionChallenge(RequiredActionContext context) {
		URI actionTokenUrl = ActionTokenUtil.createActionToken(
			AppSetupActionToken.class,
			context.getAuthenticationSession(),
			context.getSession(),
			context.getRealm(),
			context.getUser(),
			context.getUriInfo()
		);

		Response challenge = context.form()
			.setAttribute("appAuthQrCode", createQrCode(actionTokenUrl.toString()))
			.setAttribute("appAuthActionTokenUrl", actionTokenUrl.toString())
			.setAttribute("appAuthStatusUrl", String.format(
				"/realms/%s/%s?%s",
				context.getRealm().getName(),
				StatusResourceProviderFactory.ID,
				context.getActionUrl().getQuery()
			))
			.createForm("app-auth-setup.ftl");
		context.challenge(challenge);
	}

	private String createQrCode(String uri) {
		try {
			int width = 400;
			int height = 400;

			QRCodeWriter writer = new QRCodeWriter();
			final BitMatrix bitMatrix = writer.encode(uri, BarcodeFormat.QR_CODE, width, height);

			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			MatrixToImageWriter.writeToStream(bitMatrix, "png", bos);
			bos.close();

			return Base64.encodeBytes(bos.toByteArray());
		} catch (WriterException | IOException e) {
			throw new RuntimeException(e);
		}
	}

	@Override
	public void processAction(RequiredActionContext context) {
		final AuthenticationSessionModel authSession = context.getAuthenticationSession();

		if (!Boolean.parseBoolean(authSession.getAuthNote("appSetupSuccessful"))) {
			URI actionTokenUrl = ActionTokenUtil.createActionToken(
				AppSetupActionToken.class,
				context.getAuthenticationSession(),
				context.getSession(),
				context.getRealm(),
				context.getUser(),
				context.getUriInfo()
			);

			String errorMessage = Boolean.parseBoolean(authSession.getAuthNote("duplicateDeviceId")) ? "appAuthSetupDuplicate" : "appAuthSetupError";

			Response challenge = context.form()
				.setAttribute("appAuthQrCode", createQrCode(actionTokenUrl.toString()))
				.setAttribute("appAuthActionTokenUrl", actionTokenUrl.toString())
				.setAttribute("appAuthStatusUrl", String.format(
					"/realms/%s/%s?%s",
					context.getRealm().getName(),
					StatusResourceProviderFactory.ID,
					context.getActionUrl().getQuery()
				))
				.setError(errorMessage)
				.createForm("app-auth-setup.ftl");
			context.challenge(challenge);
			return;
		}
		context.success();
	}

	@Override
	public void close() {

	}

	@Override
	public String getCredentialType(KeycloakSession keycloakSession, AuthenticationSessionModel authenticationSessionModel) {
		return AppCredentialModel.TYPE;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/AppRequiredActionFactory.java
================
package netzbegruenung.keycloak.app;

import org.keycloak.Config;
import org.keycloak.authentication.RequiredActionFactory;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;

public class AppRequiredActionFactory implements RequiredActionFactory {

	private static final AppRequiredAction SINGLETON = new AppRequiredAction();

	@Override
	public String getDisplayText() {
		return "Update App Authenticator";
	}

	@Override
	public RequiredActionProvider create(KeycloakSession keycloakSession) {
		return SINGLETON;
	}

	@Override
	public void init(Config.Scope scope) {

	}

	@Override
	public void postInit(KeycloakSessionFactory keycloakSessionFactory) {

	}

	@Override
	public void close() {

	}

	@Override
	public String getId() {
		return AppRequiredAction.PROVIDER_ID;
	}
}

================
File: app-authenticator/src/main/java/netzbegruenung/keycloak/app/AuthenticationUtil.java
================
package netzbegruenung.keycloak.app;

import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import netzbegruenung.keycloak.app.credentials.AppCredentialData;
import org.apache.commons.codec.binary.Base64;
import org.jboss.logging.Logger;
import org.keycloak.common.util.Time;
import org.keycloak.models.UserModel;

import java.security.*;
import java.security.spec.EncodedKeySpec;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.List;
import java.util.Map;

public class AuthenticationUtil {

	private static final Logger logger = Logger.getLogger(AuthenticationUtil.class);
	private static final Splitter.MapSplitter signatureMapSplitter = Splitter.on(",").withKeyValueSeparator(":");

	public static Map<String, String> getSignatureMap(List<String> signatureHeaders) {
		if (signatureHeaders.isEmpty()) {
			return null;
		}

		String signatureHeader = signatureHeaders.get(0);
		Map<String, String> signatureMap = signatureMapSplitter.split(signatureHeader);

		if (
			!signatureMap.containsKey("signature")
			|| !signatureMap.containsKey("keyId")
			|| !signatureMap.containsKey("created")
		) {
			logger.warnf("Failed to parse signature header: header must at least contain keys: signature, keyId, created");
			return null;
		}

		try {
			if (Long.parseLong(signatureMap.get("created")) > Time.currentTimeMillis() + 1000 * 10) {
				logger.warnf("Failed to parse signature header: created is in the future device ID [%s]", signatureMap.get("keyId"));
				return null;
			}
		} catch (NumberFormatException e) {
			logger.warnf(e, "Failed to parse signature header: created is not a parsable long device ID [%s]", signatureMap.get("keyId"));
			return null;
		}

		return signatureMap;
	}

	public static String getSignatureString(Map<String, String> signedData) {
		return Joiner.on(",").withKeyValueSeparator(":").join(signedData);
	}

	public static boolean verifyChallenge(UserModel user, AppCredentialData appCredentialData, String signedData, String signature) {
		try {
			KeyFactory keyFactory = KeyFactory.getInstance(appCredentialData.getKeyAlgorithm());
			byte[] publicKeyBytes = Base64.decodeBase64(appCredentialData.getPublicKey());
			EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);
			PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);

			Signature sign = Signature.getInstance(appCredentialData.getSignatureAlgorithm());
			sign.initVerify(publicKey);
			sign.update(signedData.getBytes());

			if (!sign.verify(Base64.decodeBase64(signature))) {
				logger.warnv("App authentication rejected: invalid signature for user [{0}]", user.getUsername());
				return false;
			}
			return true;
		} catch (NoSuchAlgorithmException | InvalidKeySpecException | SignatureException | InvalidKeyException e) {
			logger.warnf(
				e,
				"App authentication rejected: signature verification failed for user: [%s], probably due to malformed signature or wrong algorithm",
				user.getUsername()
			);
			return false;
		}
	}

}

================
File: app-authenticator/src/main/resources/META-INF/services/org.keycloak.authentication.actiontoken.ActionTokenHandlerFactory
================
netzbegruenung.keycloak.app.actiontoken.AppSetupActionTokenHandler
netzbegruenung.keycloak.app.actiontoken.AppAuthActionTokenHandler

================
File: app-authenticator/src/main/resources/META-INF/services/org.keycloak.authentication.AuthenticatorFactory
================
netzbegruenung.keycloak.app.AppAuthenticatorFactory

================
File: app-authenticator/src/main/resources/META-INF/services/org.keycloak.authentication.RequiredActionFactory
================
netzbegruenung.keycloak.app.AppRequiredActionFactory

================
File: app-authenticator/src/main/resources/META-INF/services/org.keycloak.connections.jpa.entityprovider.JpaEntityProviderFactory
================
netzbegruenung.keycloak.app.jpa.ChallengeJpaEntityProviderFactory

================
File: app-authenticator/src/main/resources/META-INF/services/org.keycloak.credential.CredentialProviderFactory
================
netzbegruenung.keycloak.app.AppCredentialProviderFactory

================
File: app-authenticator/src/main/resources/META-INF/services/org.keycloak.services.resource.RealmResourceProviderFactory
================
netzbegruenung.keycloak.app.rest.ChallengeResourceProviderFactory
netzbegruenung.keycloak.app.rest.StatusResourceProviderFactory

================
File: app-authenticator/src/main/resources/META-INF/challenge-changelog.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.16.xsd">

    <changeSet author="giuliano.mele@verdigado.com" id="app-auth-challenge">

        <createTable tableName="APP_AUTH_CHALLENGE">
            <column name="ID" type="UUID">
                <constraints nullable="false" primaryKey="true" primaryKeyName="PK_APP_AUTH_CHALLENGE"/>
            </column>
            <column name="REALM_ID" type="VARCHAR(36)"/>
            <column name="USER_ID" type="VARCHAR(36)"/>
            <column name="TARGET_URL" type="VARCHAR(1023)">
                <constraints nullable="false"/>
            </column>
            <column name="DEVICE_ID" type="VARCHAR(255)">
                <constraints nullable="false"/>
            </column>
            <column name="SECRET" type="VARCHAR(1023)">
                <constraints nullable="false"/>
            </column>
            <column name="UPDATED_TIMESTAMP" type="BIGINT">
                <constraints nullable="false"/>
            </column>
            <column name="IP_ADDRESS" type="VARCHAR(63)"/>
            <column name="DEVICE" type="VARCHAR(63)"/>
            <column name="BROWSER" type="VARCHAR(63)"/>
            <column name="OS" type="VARCHAR(63)"/>
            <column name="OS_VERSION" type="VARCHAR(63)"/>
        </createTable>
        <addUniqueConstraint columnNames="REALM_ID, DEVICE_ID" constraintName="UC_CHALLENGE_REALM_ID" tableName="APP_AUTH_CHALLENGE"/>
        <createIndex indexName="IDX_CHALLENGE_REALM_ID" tableName="APP_AUTH_CHALLENGE">
            <column name="REALM_ID"/>
            <column name="DEVICE_ID"/>
        </createIndex>
        <addForeignKeyConstraint baseColumnNames="REALM_ID" baseTableName="APP_AUTH_CHALLENGE" constraintName="FK_APP_AUTH_CHALLENGE_ON_REALM"
								 onDelete="CASCADE" referencedColumnNames="ID" referencedTableName="REALM"/>
        <addForeignKeyConstraint baseColumnNames="USER_ID" baseTableName="APP_AUTH_CHALLENGE" constraintName="FK_APP_AUTH_CHALLENGE_ON_USER"
								 onDelete="CASCADE" referencedColumnNames="ID" referencedTableName="USER_ENTITY"/>
    </changeSet>

	<changeSet id="app-auth-challenge-23.0.2" author="giuliano.mele@verdigado.com">
		<delete tableName="APP_AUTH_CHALLENGE" />
		<addColumn tableName="APP_AUTH_CHALLENGE">
			<column name="CLIENT_ID" type="VARCHAR(36)">
				<constraints nullable="false"/>
			</column>
		</addColumn>
		<addForeignKeyConstraint baseTableName="APP_AUTH_CHALLENGE" baseColumnNames="CLIENT_ID" onDelete="CASCADE"
								 referencedTableName="CLIENT" referencedColumnNames="ID" constraintName="FK_APP_AUTH_CHALLENGE_ON_CLIENT"/>
	</changeSet>

	<changeSet id="app-auth-challenge-23.0.4" author="giuliano.mele@verdigado.com">
		<delete tableName="APP_AUTH_CHALLENGE" />
		<addColumn tableName="APP_AUTH_CHALLENGE">
			<column name="EXPIRES_AT" type="BIGINT" defaultValueNumeric="0">
				<constraints nullable="false"/>
			</column>
		</addColumn>
		<createIndex tableName="APP_AUTH_CHALLENGE" indexName="IDX_CHALLENGE_DEVICE_ID">
			<column name="DEVICE_ID" />
		</createIndex>
	</changeSet>

	<changeSet id="app-auth-challenge-25.0.1" author="giuliano.mele@verdigado.com">
		<modifyDataType tableName="APP_AUTH_CHALLENGE"
			columnName="TARGET_URL"
			newDataType="TEXT" />
	</changeSet>

</databaseChangeLog>

================
File: app-authenticator/src/main/resources/theme-resources/messages/messages_de.properties
================
appConfigTitle=App Authentifizierung Einrichten
appConfigStep1=Öffne die App auf deinem mobilen Gerät und scanne den Code oder gib die Action Token URL direkt ein.
appConfigStep2=Bestätige den Dialog, um die Einrichtung abzuschließen.
appConfigStep3=Nachdem die Einrichtung abgeschlossen ist, kannst du auf Absenden klicken.
appAuthDisplayName=App Authentifizierung
appAuthHelpText=Bestätige die Anmeldung durch die App.
appAuthTitle=App Authentifizierung
appAuthInstructions=Bestätige die Anmeldung durch die App.
appAuthSetupError=Einrichtung der App Authentifizierung ist fehlgeschlagen. Bitte versuche es nochmal.
appAuthSetupDuplicate=Einrichtung der App Authentifizierung ist fehlgeschlagen. Gerät ist bereits für deinen Account registriert.
appAuthSetupActionTokenLabel=Action Token URL
appAuthError=Authentifizierung durch die App ist fehlgeschlagen. Bitte versuche es nochmal.
appAuthCriticalError=Ein kritischer Fehler ist aufgetreten, bitte kontaktiere eine Administrator*in.
appAuthRejected=Authentifizierung wurde von der App abgelehnt.
APP_CREDENTIAL-display-name=App Authentifizierung

================
File: app-authenticator/src/main/resources/theme-resources/messages/messages_en.properties
================
appConfigTitle=App Authenticator Setup
appConfigStep1=Open the application on your mobile device and scan the code or enter the action token URL directly.
appConfigStep2=Confirm the dialog in the app to finish the setup.
appConfigStep3=After setup completion you can click on Submit.
appAuthDisplayName=App Authentication
appAuthHelpText=Confirm login by App.
appAuthTitle=App Authenticator
appAuthInstructions=Confirm login by app.
appAuthSetupError=Failed to set up app authentication. Please try again.
appAuthSetupDuplicate=Failed to set up app authentication. Device already registered for your account.
appAuthSetupActionTokenLabel=Action Token URL
appAuthError=Failed to authenticate by app. Please try again.
appAuthCriticalError=A critical error occurred, please contact an admin.
appAuthRejected=Authentication rejected by app.
APP_CREDENTIAL-display-name=App Authentication

================
File: app-authenticator/src/main/resources/theme-resources/templates/app-auth-selection.ftl
================
<#import "template.ftl" as layout>
<@layout.registrationLayout displayInfo=false; section>
    <#if section = "header" || section = "show-username">
        <script type="text/javascript">
            function fillAndSubmit(authExecId) {
                document.getElementById('app-credential-hidden-input').value = authExecId;
                document.getElementById('kc-select-app-credential').submit();
            }
        </script>
        <#if section = "header">
            ${msg("loginChooseAuthenticator")}
        </#if>
    <#elseif section = "form">

        <form id="kc-select-app-credential" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
            <div class="${properties.kcSelectAuthListClass!}">
                <#list appCredentials as appCredential>
                    <div class="${properties.kcSelectAuthListItemClass!}" onclick="fillAndSubmit('${appCredential.id}')">

                        <div class="${properties.kcSelectAuthListItemIconClass!}">
                            <i class="fa fa-mobile" style="font-size: 3rem;"></i>
                        </div>
                        <div class="${properties.kcSelectAuthListItemBodyClass!}">
                            <div class="${properties.kcSelectAuthListItemHeadingClass!}">
                                ${msg('${appCredential.credentialData?eval_json.deviceOs}')}
                            </div>
                            <div class="${properties.kcSelectAuthListItemDescriptionClass!}">
                                ${msg('${appCredential.createdDate?number_to_datetime}')}
                            </div>
                        </div>
                        <div class="${properties.kcSelectAuthListItemFillClass!}"></div>
                        <div class="${properties.kcSelectAuthListItemArrowClass!}">
                            <i class="${properties.kcSelectAuthListItemArrowIconClass!}"></i>
                        </div>
                    </div>
                </#list>
                <input type="hidden" id="app-credential-hidden-input" name="app-credential" />
            </div>
        </form>

    </#if>
</@layout.registrationLayout>

================
File: app-authenticator/src/main/resources/theme-resources/templates/app-auth-setup.ftl
================
<#import "template.ftl" as layout>
<@layout.registrationLayout; section>
    <#if section = "header">
        ${msg("appConfigTitle")}
    <#elseif section = "form">
        <form id="kc-app-authentication" onsubmit="confirm.disabled = true; return true;" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
            <ol id="kc-app-setup">
                <li>
                    <p>${msg("appConfigStep1")}</p>
                    <img src="data:image/png;base64, ${appAuthQrCode}" alt="Figure: Barcode" width="400" height="400"><br/>
                    <div class="${properties.kcFormGroupClass!}">
                        <div class="${properties.kcLabelWrapperClass!}">
                            <label for="actiontoken" class="${properties.kcLabelClass!}">${msg("appAuthSetupActionTokenLabel")}</label>
                        </div>
                        <div class="${properties.kcInputWrapperClass!}" style="display: flex;">
                            <input type="text" name="actiontoken" class="${properties.kcInputClass!}" readonly value="${appAuthActionTokenUrl}" />
                            <button type="button" onclick="navigator.clipboard.writeText(actiontoken.value);">
                                <i class="fa fa-clipboard"></i>
                            </button>
                        </div>
                    </div>
                </li>
                <li>
                    <p>${msg("appConfigStep2")}</p>
                </li>
                <li>
                    <p>${msg("appConfigStep3")}</p>
                </li>
            </ol>
            <#if isAppInitiatedAction??>
				<button type="submit"
						class="${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!}"
						name="cancel-aia" value="true" />${msg("doCancel")}
				</button>
            </#if>
        </form>
		<script type="text/javascript">
			const source = new EventSource("${appAuthStatusUrl?no_esc}");
			source.addEventListener("status", (event) => {
				if (event.data === 'ready') {
					source.close();
					document.getElementById('kc-app-authentication').submit();
				}
			});
		</script>
    </#if>
</@layout.registrationLayout>

================
File: app-authenticator/src/main/resources/theme-resources/templates/app-login.ftl
================
<#import "template.ftl" as layout>
<@layout.registrationLayout displayInfo=true; section>
    <#if section = "header">
        ${msg("appAuthTitle")}
    <#elseif section = "form">
        <form id="kc-app-authentication" onsubmit="confirm.disabled = true; return true;" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
        </form>
		<#if appAuthStatusUrl??>
			<script type="text/javascript">
				const source = new EventSource("${appAuthStatusUrl?no_esc}");
				source.onmessage = (event) => {
					if (event.data === 'ready') {
						source.close();
						document.getElementById('kc-app-authentication').submit();
					}
				}
			</script>
		</#if>
    <#elseif section = "info" >
        ${msg("appAuthInstructions")}
    </#if>
</@layout.registrationLayout>

================
File: app-authenticator/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>keycloak-mfa-tools</artifactId>
        <groupId>netzbegruenung</groupId>
        <version>26.1.2</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>app-authenticator</artifactId>

    <dependencies>
        <dependency>
            <groupId>com.google.firebase</groupId>
            <artifactId>firebase-admin</artifactId>
            <version>9.4.3</version>
        </dependency>
		<dependency>
			<groupId>org.keycloak</groupId>
			<artifactId>keycloak-quarkus-server-app</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- Necessary for proper execution of IDELauncher -->
		<!-- Can be removed as part of the https://github.com/keycloak/keycloak/issues/22455 enhancement -->
		<dependency>
			<groupId>io.quarkus</groupId>
			<artifactId>quarkus-vertx-http-dev-ui-resources</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- this dependency is necessary to start the IDELauncher -->
		<dependency>
			<groupId>com.oracle.database.jdbc</groupId>
			<artifactId>ojdbc11</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- https://github.com/keycloak/keycloak/issues/34549 -->
		<dependency>
			<groupId>io.mvnpm</groupId>
			<artifactId>importmap</artifactId>
			<scope>provided</scope>
		</dependency>
    </dependencies>

    <build>
        <finalName>${project.groupId}.${project.artifactId}-v${project.version}</finalName>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
			<plugin>
				<groupId>io.quarkus</groupId>
				<artifactId>quarkus-maven-plugin</artifactId>
				<configuration>
					<argsString>start-dev --db-url jdbc:h2:file:${project.parent.basedir}/h2db/app;AUTO_SERVER=TRUE;NON_KEYWORDS=VALUE</argsString>
				</configuration>
			</plugin>
        </plugins>
    </build>

</project>

================
File: app-authenticator/README.md
================
# App Authenticator

This project is about creating an extension for Keycloak to improve two-factor authentication (2FA) by allowing users to use an authenticator app. The goal is to make the process more user-friendly. Instead of requiring users to input Time-based One-Time Password (TOTP) codes, they can simply accept or reject login attempts through the app.

During the authentication process, a cryptographic keypair generated by the client is utilized. This keypair enhances security by ensuring the authenticity of the users during the authentication process.

The extension provides the necessary API endpoints to implement such an authenticator app.

## Concept

Summary of the intended flow:

1. Activation Token Exchange: Keycloak generates an Activation Token that is passed to the client (copy paste or scanning a QR-code)

2. Key Pair Generation: The user's device generates a cryptographic key pair that is put into the device's secure storage. The public key is then registered with Keycloak, associating it with the respective user account. The client also generates and sends a unique authenticator id (uuid).

3. Challenge Transmission: When a user initiates a login attempt, Keycloak sends a challenge to the user's device. This challenge can be transmitted either through a push notification triggered by the login attempt or by polling a specific endpoint on Keycloak.

4. Challenge Signing: The user's device signs the challenge using its private key. This signed challenge is then sent back to Keycloak.

5. Verification Process: Keycloak verifies the signature with the user's public key to ascertain the authenticity of the response. Based on this verification, Keycloak can make an informed decision to either accept or reject the login attempt.

## API Documentation

### Activation Token URL

This is an example of the activation token URL that is displayed on the Keycloak My Account Console as QR-Code and copy paste option.

```plain
http://192.168.2.127:8080/realms/dev/login-actions/action-token?key=eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIxYWEzY2FhMS00ZmEwLTQzNTUtYWE1ZC1lZTVhNzc4OTA0NGYifQ.eyJleHAiOjE3MDE0Mjg0NjQsImlhdCI6MTcwMTQyODE2NCwianRpIjoiZTlhZWEyYzQtOWM4Ny00MjBkLTg2NjctNjg0YzA5MjM0ZTA3IiwiaXNzIjoiaHR0cDovLzE5Mi4xNjguMi4xMjc6ODA4MC9yZWFsbXMvZGV2IiwiYXVkIjoiaHR0cDovLzE5Mi4xNjguMi4xMjc6ODA4MC9yZWFsbXMvZGV2Iiwic3ViIjoiYjViZjYzOTYtMjFjZC00NjZjLTk2MzMtMGRlM2ExNTJiYTYzIiwidHlwIjoiYXBwLXNldHVwLWFjdGlvbi10b2tlbiIsIm5vbmNlIjoiZTlhZWEyYzQtOWM4Ny00MjBkLTg2NjctNjg0YzA5MjM0ZTA3Iiwib2FzaWQiOiIwYTE4YTM0MS01ZWE3LTRlZjgtYmRjNS1kZTdmNDY5MjcyYjEuUldfTERIazV6QjguMjk1OTViZmEtNzU4ZS00MjFiLWE4ZDMtMGFmYjQ4ZDE3MjhkIn0.XLh09uLq9Ybx_fCIcMhWcNELy9wnPaGMZ8pRusJ_b_g&client_id=account-console&tab_id=RW_LDHk5zB8
```

**URL Parameters**

| Key       | Example Value   | Description                          |
| --------- | --------------- | ------------------------------------ |
| tab_id    | RW_LDHk5zB8     | Tab Id of the User's Browser Session |
| client_id | account-console | Client ID the User is logging in     |
| key       | _see below_     | Keycloak Action Token as JWT         |

**Decoded Keycloak Action Token**

**Header**

```json
{
	"alg": "HS256",
	"typ": "JWT",
	"kid": "1aa3caa1-4fa0-4355-aa5d-ee5a7789044f"
}
```

**Payload**

```json
{
	"exp": 1701428464,
	"iat": 1701428164,
	"jti": "e9aea2c4-9c87-420d-8667-684c09234e07",
	"iss": "http://192.168.2.127:8080/realms/dev",
	"aud": "http://192.168.2.127:8080/realms/dev",
	"sub": "b5bf6396-21cd-466c-9633-0de3a152ba63",
	"typ": "app-setup-action-token",
	"nonce": "e9aea2c4-9c87-420d-8667-684c09234e07",
	"oasid": "0a18a341-5ea7-4ef8-bdc5-de7f469272b1.RW_LDHk5zB8.29595bfa-758e-421b-a8d3-0afb48d1728d"
}
```

**Signature**

```plain
XLh09uLq9Ybx_fCIcMhWcNELy9wnPaGMZ8pRusJ_b_g
```

### Error Responses

**About HTTP Status Codes**

-   `4xx` indicate a problem caused by the client.
-   `401 Unauthorized` Is returned when the client failed to prove it's identity. E.g. missing authentication information, invalid credentials or a presented JWT that failed verification.
-   `403 Forbidden` is returned when the client proved it's identity but is not allowed to access the resource because of missing privileges.
-   `5xx`indicate a server sided problem. Error codes from this range **MAY NOT** be returned if the problem was caused by the client. Any endpoint can return with this status code.

**Error Object**

Any error response can optionally return an error object as JSON in the body with the following shape. Since it is not possible to return a customized error on the action token endpoint, only the HTTP status code is returned without a body.

```json
{
	"error": "some_error_type",
	"message": "details about the occurred error"
}
```

### Authentication

**Signature Tokens**

The API endpoints require an authentication mechanism that leverages client-side generated keypairs. While drafts for HTTP Message Signatures exist, they are no well-established standards.
[draft-ietf-httpbis-message-signatures](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-message-signatures).

Instead of implementing concepts from this unfinished draft, the API uses client-side generated JSON Web Tokens (JWTs) as a form of request signature. The JWTs are signed using a private key stored on the client and transmitted in the `x-signature` header.

The client should use the authenticator id as the `kid` claim and use an asymmetric signature algorithm. The acceptable algorithms are:

-   `PS512` with an `RSASSA-PSS` asymmetric key
-   `ES512` with an `EC` asymmetric key

The JWT payload should contain:

-   The user id as `sub` claim, which the client can extract from the `sub` claim of the action token issued by Keycloak via the activation token URL.
-   An expiration time of approximately 30 seconds to mitigate replay attacks.
-   A UUID for the JWT in the `jti` claim, which can be used to implement one-time tokens. The token id should be stored on the Keycloak side at least until the token expires.
-   A `typ` claim similar to the Keycloak action tokens, containing a value for the corresponding endpoint or action, e.g., `get-challenges`.
-   Any additional request parameters that need to be signed.

### Endpoints

#### Authenticator Setup

```
GET /realms/{realmId}/login-actions/action-token
```

##### Authentication

-   The Keycloak action token (JWT) that was exchanged beforehand via the activation token URL needs to be passed in the `key` query parameter.
-   The signature token (JWT) generated by the client in the `x-signature` header with claim `typ` = `app-setup-signature-token`.

**Consistency Check**

The signature token is not used for authentication here but rather for a **consistency check** to confirm that this token can be verified with the public key sent in this request

##### Parameters

| Name                        | In    | Description                                                                                                                                          |
| --------------------------- | ----- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `realmId`                   | path  | The Keycloak realm ID                                                                                                                                |
| `client_id`                 | query | The Keycloak client id. This should always be `account-console` for the setup step. Client receives this value from the activation token URL.        |
| `tab_id`                    | query | The Keycloak tab ID in the browser session where the user is setting up the authenticator. Client receives this value from the activation token URL. |
| `key`                       | query | The from Keycloak generated action token in form of a JWT. Client receives this value from the activation token URL.                                 |
| `authenticator_id`          | query | A unique ID to identify the authenticator.                                                                                                           |
| `device_os`                 | query | The platform on which the authenticator app is running on. Supported values are: `android` and `ios`                                                 |
| `public_key`                | query | The X.509 public key (e.g. as PKCS#8 base64 encoded) used to verify signatures                                                                       |
| `key_algorithm`             | query | Key algorithm of the public key                                                                                                                      |
| `device_push_id (optional)` | query | The platform specific ID to receive push notifications. For android this is the Firebase ID                                                          |

##### Responses

-   `2xx` Authenticator was successfully registered
-   `400 Bad Request` Missing or invalid request parameters. This includes:
    -   parsing of the JWT failed (invalid format)
    -   request parameters are invalid (e.g. the signature or key algorithm is not supported)
-   `401 Unauthorized` Verification of the JWT from the `key` query parameter failed in any form (expired, missing claims, invalid signature)
-   `409 Conflict` The authenticator ID is already registered
-   `422 Unprocessable Entity`
    Verification of the signature token failed with the given `public_key` and `key_algorithm` sent by the client.

#### Get Challenges

```
/realms/{realmId}/challenges
```

##### Authentication

-   The signature token (JWT) generated by the client in the `x-signature` header with claim `typ` = `app-challenges-signature-token`.

##### Parameters

**Note:** The authenticator id is retrieved from the `kid` header of the JWT.

| Name      | In   | Description           |
| --------- | ---- | --------------------- |
| `realmId` | path | The Keycloak realm ID |

##### Responses

-   `2xx` Login challenge dtos as array
-   `400 Bad Request` the `x-signature` header has a wrong format
-   `401 Unauthorized` The `x-signature` header is missing or verification failed
-   `412 Precondition Failed` The referenced `kid` (authenticator ID) in the signature token does not exist

##### ChallengeDTO

```json
{
	"userName": "johndoe",
	"userFirstName": "John",
	"userLastName": "Doe",
	"targetUrl": "http://192.168.2.127:8080/realms/dev/login-actions/action-token?key=eyJh...",
	"codeChallenge": "FlJj9I4WoezeR3MN...",
	"updatedTimestamp": 1701426908708,
	"ipAddress": "192.168.2.127",
	"device": "Other",
	"browser": "Firefox/120.0",
	"os": "Ubuntu",
	"osVersion": "Unknown"
}
```

###### Target URL Example

Example of the value in `targetUrl`

```plain
http://192.168.2.127:8080/realms/dev/login-actions/action-token?key=eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIxYWEzY2FhMS00ZmEwLTQzNTUtYWE1ZC1lZTVhNzc4OTA0NGYifQ.eyJleHAiOjE3MDE0MjcyMDgsImlhdCI6MTcwMTQyNjkwOCwianRpIjoiNDNmOWFmMTItZTdjMS00NWJlLTliMDUtYTc3M2ZlNDBiNjk4IiwiaXNzIjoiaHR0cDovLzE5Mi4xNjguMi4xMjc6ODA4MC9yZWFsbXMvZGV2IiwiYXVkIjoiaHR0cDovLzE5Mi4xNjguMi4xMjc6ODA4MC9yZWFsbXMvZGV2Iiwic3ViIjoiYjViZjYzOTYtMjFjZC00NjZjLTk2MzMtMGRlM2ExNTJiYTYzIiwidHlwIjoiYXBwLWF1dGgtYWN0aW9uLXRva2VuIiwibm9uY2UiOiI0M2Y5YWYxMi1lN2MxLTQ1YmUtOWIwNS1hNzczZmU0MGI2OTgiLCJvYXNpZCI6IjRjZTgxYTJjLTlmYjEtNDI2Ni04NjcwLWVmZjIwNzgxNjZmMS5OSzRoRTJvLTZhMC4yOTU5NWJmYS03NThlLTQyMWItYThkMy0wYWZiNDhkMTcyOGQifQ.Nc5dQmBhkuShkLJAMgoHEDdsRWz04594AtIJgCwTICM&client_id=account-console&tab_id=NK4hE2o-6a0
```

**Parameters**

| Key       | Example Value   | Description                          |
| --------- | --------------- | ------------------------------------ |
| tab_id    | NK4hE2o-6a0     | Tab Id of the User's Browser Session |
| client_id | account-console | Client ID the User is logging in     |
| key       | _see below_     | Keycloak Action Token as JWT         |

**Decoded Keycloak Action Token**

**Header**

```json
{
	"alg": "HS256",
	"typ": "JWT",
	"kid": "1aa3caa1-4fa0-4355-aa5d-ee5a7789044f"
}
```

**Payload**

```json
{
	"exp": 1701427208,
	"iat": 1701426908,
	"jti": "43f9af12-e7c1-45be-9b05-a773fe40b698",
	"iss": "http://192.168.2.127:8080/realms/dev",
	"aud": "http://192.168.2.127:8080/realms/dev",
	"sub": "b5bf6396-21cd-466c-9633-0de3a152ba63",
	"typ": "app-auth-action-token",
	"nonce": "43f9af12-e7c1-45be-9b05-a773fe40b698",
	"oasid": "4ce81a2c-9fb1-4266-8670-eff2078166f1.NK4hE2o-6a0.29595bfa-758e-421b-a8d3-0afb48d1728d"
}
```

**Signature**

```plain
Nc5dQmBhkuShkLJAMgoHEDdsRWz04594AtIJgCwTICM
```

#### Reply Challenge Endpoint

```
GET /realms/{realmId}/login-actions/action-token
```

#### Authentication

-   The JWT generated by Keycloak in the `key`query parameter. It was given to the client via the challenges endpoint or push notification.
-   The signature token (JWT) generated by the client in the `x-signature` header with claims:
    -   `typ`: `app-auth-signature-token`
    -   `codeChallenge`: The challenge value to sign

#### Parameters

| Name        | In    | Description                                                                                                                                                      |
| ----------- | ----- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `realmId`   | path  | The Keycloak realm ID                                                                                                                                            |
| `client_id` | query | The Keycloak client ID. This should always be `account-console` for the setup step. Client receives this value from the `targetUrl` from the ChallengeDTO.       |
| `tab_id`    | query | The Keycloak tab ID in the browser session where the user is setting up the authenticator. Client receives this value from the `targetUrl` from the ChallengeDTO |
| `key`       | query | The from Keycloak generated action token in form of a JWT. Client receives this value from the `targetUrl` from the ChallengeDTO.                                |
| `granted`   | query | boolean that indicates of the login attempt was granted or not                                                                                                   |

#### Responses

-   `2xx`challenge reply was successfully processed

-   `400 Bad Request` Missing or invalid request parameters. This includes:
    -   parsing of the JWT failed (invalid format)
    -   the `x-signature` header has a wrong format
-   `401 Unauthorized`
    -   The `x-signature` header is missing or signature verification failed
    -   The required JWT in query parameter `key` is expired or verification of the JWT failed in any other form (missing claims, invalid signature)
-   `412 Precondition Failed` The referenced key (authenticator ID) in the request signature does not exist

## Development Notes

-   The API is based on Keycloaks Action Token Handler to "implement any functionality that initiates or modifies authentication session using action token handler SPI" (Ref. <https://www.keycloak.org/docs/latest/server_development/index.html#_action_token_handler_spi>)
-   HTTP respones from action token endpoints cannot be modified. They always return HTML
-   The status code can be modifierd but the response body will be empty

-   Public Key is assumed to be encoded according to the X.509 standard: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/spec/X509EncodedKeySpec.html

-   Valid Key Algorithms: https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#keyfactory-algorithms

-   Valid Signature Algorithms: https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#signature-algorithms

-   During signature validation the app authenticator instantiates a KeyFactory object with the provided key_algorithm.
    The KeyFactory object will then use the public key specification (public_key) to generate a public key object.
    Finally, a signature object is instantiated by signature_algorithm and initialized with the public key object to verify the message signature.

Refs:

-   https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/KeyFactory.html#getInstance(java.lang.String)
-   https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/KeyFactory.html#generatePublic(java.security.spec.KeySpec)
-   https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/security/Signature.html#getInstance(java.lang.String)

================
File: app-authenticator-cli/.gitignore
================
node_modules
data.json

================
File: app-authenticator-cli/authenticator.js
================
import { Command } from "commander";
import inquirer from "inquirer";
import axios from "axios";
import * as jose from "jose";
import { v4 as uuidv4 } from "uuid";
import fs from "fs/promises";
import { resolve, dirname } from "path";
import { fileURLToPath } from "url";
import * as AxiosLogger from "axios-logger";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const DATA_FILE = resolve(__dirname, "./data.json");

async function main() {
	const program = new Command();

	program
		.name("authenticator-cli")
		.description("CLI to test Keycloak authenticator API");

	program
		.command("setup")
		.description(
			"Generate an asymmetric keypair and complete authenticator setup"
		)
		.action(commandSetup);

	program
		.command("auth")
		.description(
			"poll the keycloak api for a login challenge and send reply"
		)
		.action(commandAuth);

	try {
		await program.parseAsync();
	} catch (err) {
		console.error("Commmand failed");

		if (!axios.isAxiosError(err)) {
			console.error(err);
		}
	}
}

// commands

async function commandSetup(_arg, _options) {
	const { activationTokenUrl } = await promptActivationTokenUrl();

	const url = new URL(activationTokenUrl);

	// get keycloak base url
	const [_matched, basePath, _realm] = url.pathname.match(
		/(.*\/realms\/([^\/]+))\//
	);
	const baseURL = `${url.origin}${basePath}`;

	// query parameters
	const clientId = url.searchParams.get("client_id");
	const tabId = url.searchParams.get("tab_id");
	const key = url.searchParams.get("key");

	// get user id from keycloak action token
	const { sub: userId } = await jose.decodeJwt(key);

	// prompt which signature algorithm to use and
	// generate new key pair
	const { alg } = await promptAlgorithm();
	const { publicKey, privateKey } = await jose.generateKeyPair(alg);
	const spkiPem = await jose.exportSPKI(publicKey);
	const spki = spkiPem.replace(
		/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,
		""
	);
	const authenticatorId = uuidv4();
	const client = new KeycloakClient({
		baseURL,
		privateKey,
		alg,
		authenticatorId,
		userId,
	});

	await client.setup({
		clientId,
		tabId,
		key,
		publicKey: spki,
		keyAlgorithm: mapKeyAlgorithm(alg),
		deviceOs: "unknown",
	});

	const data = {
		baseURL,
		authenticatorId,
		userId,
		alg,
		privateKey: await jose.exportJWK(privateKey),
		publicKey: await jose.exportJWK(publicKey),
	};

	await saveData(data);
}

async function commandAuth(_arg, _options) {
	const {
		baseURL,
		authenticatorId,
		userId,
		alg,
		privateKey: privateKeyJwk,
	} = await loadData();

	const privateKey = await jose.importJWK(privateKeyJwk, alg);

	const client = new KeycloakClient({
		baseURL,
		privateKey,
		alg,
		authenticatorId,
		userId,
	});

	const [challenge] = await client.getChallanges();

	if (!challenge) {
		console.log("No current login attempts");
		return;
	}

	console.log("Login Attempt", challenge);

	const { granted } = await promptGranted();

	const { codeChallenge, targetUrl } = challenge;

	const url = new URL(targetUrl);
	const clientId = url.searchParams.get("client_id");
	const tabId = url.searchParams.get("tab_id");
	const key = url.searchParams.get("key");

	await client.replyChallenge({
		clientId,
		codeChallenge,
		granted: granted.toLowerCase() === "accept",
		key,
		tabId,
	});
}

// prompts

function promptActivationTokenUrl() {
	return inquirer.prompt([
		{
			type: "string",
			name: "activationTokenUrl",
			message:
				"Enter the Activation Token Url from the Keycloak Account Console:",
		},
	]);
}

function promptAlgorithm() {
	return inquirer.prompt([
		{
			type: "list",
			name: "alg",
			message: "Select a JWK algorithm:",
			choices: ["PS256", "PS512", "ES256", "ES512"],
		},
	]);
}

function promptGranted() {
	return inquirer.prompt([
		{
			type: "list",
			name: "granted",
			message: "Accept or reject the login:",
			choices: ["Accept", "Reject"],
		},
	]);
}

// client

/**
 * @typedef {{
 *  userName: string
 *  userFirstName: string
 *  userLastName: string
 *  targetUrl: string
 *  secret: string
 *  updatedTimestamp: string
 *  ipAddress: string
 *  device: string
 *  browser: string
 *  os: string
 *  osVersion: string
 * }} ChallengeDto
 */

class KeycloakClient {
	constructor({ baseURL, privateKey, alg, authenticatorId, userId }) {
		this._authenticatorId = authenticatorId;
		this._userId = userId;
		this._privateKey = privateKey;
		this._alg = alg;

		this._client = axios.create({
			baseURL,
		});

		this._client.interceptors.request.use(AxiosLogger.requestLogger);

		this._client.interceptors.response.use(
			AxiosLogger.responseLogger,
			(err) =>
				AxiosLogger.errorLogger(err, {
					params: true,
					headers: true,
					data: true,
					status: true,
					statusText: true,
				})
		);
	}

	_createSignatureToken(payload) {
		return new jose.SignJWT(payload)
			.setProtectedHeader({
				alg: this._alg,
				kid: this._authenticatorId,
				typ: "JWT",
			})
			.setIssuedAt()
			.setExpirationTime("30s")
			.setSubject(this._userId)
			.setJti(uuidv4())
			.sign(this._privateKey);
	}

	async setup({
		clientId,
		tabId,
		key,
		deviceOs,
		devicePushId,
		publicKey,
		keyAlgorithm,
	}) {
		const jwt = await this._createSignatureToken({ typ: "app-setup-signature-token" });

		await this._client.get("/login-actions/action-token", {
			headers: {
				"x-signature": jwt,
			},
			params: {
				client_id: clientId,
				tab_id: tabId,
				key,
				authenticator_id: this._authenticatorId,
				device_os: deviceOs,
				device_push_id: devicePushId,
				public_key: publicKey,
				key_algorithm: keyAlgorithm,
			},
		});
	}

	/**
	 *
	 * @returns {Promise<ChallengeDto[]>}
	 */
	async getChallanges() {
		const jwt = await this._createSignatureToken({
			typ: "app-challenges-signature-token",
		});
		const { data: challenges } = await this._client.get("/challenges", {
			headers: {
				"x-signature": jwt,
			},
		});
		return challenges;
	}

	async replyChallenge({ clientId, tabId, key, codeChallenge, granted }) {
		const jwt = await this._createSignatureToken({
			typ: "app-auth-signature-token",
			codeChallenge,
		});

		await this._client.get("/login-actions/action-token", {
			headers: {
				"x-signature": jwt,
			},
			params: {
				client_id: clientId,
				tab_id: tabId,
				key: key,
				granted: granted,
			},
		});
	}
}

// utils

async function saveData(data) {
	await fs.writeFile(DATA_FILE, JSON.stringify(data, null, 4));
}

async function loadData() {
	return JSON.parse(await fs.readFile(DATA_FILE));
}

/**
 * map JWT signature algorithm to keycloak key algorithm
 */
function mapKeyAlgorithm(alg) {
	const valueMap = {
		PS256: "RSASSA-PSS",
		PS512: "RSASSA-PSS",
		ES256: "EC",
		ES512: "EC",
	};
	if (valueMap[alg] === undefined) {
		throw new Error(`unknown alg ${alg}`);
	}
	return valueMap[alg];
}

main();

================
File: app-authenticator-cli/package.json
================
{
  "name": "authenticator",
  "type": "module",
  "version": "1.0.0",
  "description": "",
  "main": "authenticator.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.6.2",
    "axios-logger": "^2.7.0",
    "commander": "^11.1.0",
    "inquirer": "^9.2.12",
    "jose": "^5.1.1",
    "uuid": "^9.0.1"
  }
}

================
File: enforce-mfa/src/main/java/netzbegruenung/keycloak/enforce_mfa/EnforceMfaAuthenticator.java
================
package netzbegruenung.keycloak.enforce_mfa;

import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.Response;
import org.jboss.logging.Logger;
import org.keycloak.authentication.*;
import org.keycloak.authentication.authenticators.conditional.ConditionalAuthenticator;
import org.keycloak.models.*;
import org.keycloak.models.utils.AuthenticationFlowResolver;
import org.keycloak.sessions.AuthenticationSessionModel;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class EnforceMfaAuthenticator implements Authenticator {

	private static final Logger logger = Logger.getLogger(EnforceMfaAuthenticator.class);

	private static final String FORM_PARAM_MFA_METHOD = "mfaMethod";
	private static final String LOCALIZATION_PREFIX = "enforceMfa";

	public static final String CONFIG_OPTIONAL_NAME = "mfaSetupOptional";
	public static final Boolean CONFIG_OPTIONAL_DEFAULT_VALUE = false;

	@Override
	public void authenticate(AuthenticationFlowContext context) {
		List<RequiredActionProviderModel> requiredActions = getAllRequiredActions(context);

		if (requiredActions.isEmpty()) {
			logger.errorv(
				"No supported required actions enabled for user {0} in realm {1}",
				context.getAuthenticationSession().getAuthenticatedUser().getId(),
				context.getRealm().getName()
			);
			Response errorResponse = context.form()
				.setError("enforceMfaIllegalState")
				.createForm("enforce-mfa.ftl");
			context.failure(AuthenticationFlowError.INTERNAL_ERROR, errorResponse);
		} else {
			Response challenge = context.form()
				.setAttribute("mfa", requiredActions)
				.setAttribute("isSetupOptional", isSetupOptional(context.getAuthenticatorConfig()))
				.setAttribute("localizationPrefix", LOCALIZATION_PREFIX)
				.createForm("enforce-mfa.ftl");
			context.challenge(challenge);
		}
	}

	/**
	 * Get available required actions for 2FA setup
	 *
	 * @param context
	 * @return available required actions
	 */
	private List<RequiredActionProviderModel> getAllRequiredActions(AuthenticationFlowContext context) {
		List<RequiredActionProviderModel> alternativeRequiredActions = new LinkedList<>();

		getExecutions(context.getSession(), context.getRealm(), context.getExecution())
			.forEachOrdered(e -> {
				if (e.isAlternative()) {
					alternativeRequiredActions.addAll(getRequiredActions(context, e));
				}
			});
		return alternativeRequiredActions;
	}

	/**
	 * Collect executions of the current flow beneath base execution
	 * e.g. with base execution MFA-Authenticate-subflow will return OTP and WebAuthn
	 *
	 * - MFA-Authenticate-subflow CONDITIONAL
	 * -- Condition - user configured REQUIRED
	 * -- OTP ALTERNATIVE
	 * -- WebAuthn ALTERNATIVE
	 *
	 * @param session
	 * @param realm
	 * @param execution
	 * @return
	 */
	private Stream<AuthenticationExecutionModel> getExecutions(KeycloakSession session, RealmModel realm, AuthenticationExecutionModel execution) {
		AuthenticationExecutionModel baseExecution = getBaseExecution(realm, execution);

		return realm.getAuthenticationExecutionsStream(baseExecution.getFlowId())
			.filter(e -> !isConditionalExecution(session, e))
			.filter(e -> !Objects.equals(execution.getId(), e.getId()) && !e.isAuthenticatorFlow());
	}

	/**
	 * Given that execution is set to Enforce-MFA, then this function will return MFA-Authenticate-subflow
	 *
	 * - MFA-Authenticate-subflow CONDITIONAL
	 * -- Condition - user configured REQUIRED
	 * -- OTP ALTERNATIVE
	 * -- WebAuthn ALTERNATIVE
	 *
	 * - Register-MFA-subflow CONDITIONAL
	 * -- Condition - user configured REQUIRED
	 * -- Enforce-MFA REQUIRED
	 *
	 * @param realm
	 * @param execution
	 * @return base execution
	 */
	private AuthenticationExecutionModel getBaseExecution(RealmModel realm, AuthenticationExecutionModel execution) {
		AuthenticationExecutionModel parentExecution = realm.getAuthenticationExecutionByFlowId(execution.getParentFlow());

		Optional<AuthenticationExecutionModel> baseExecution = realm.getAuthenticationExecutionsStream(parentExecution.getParentFlow())
			.filter(AuthenticationExecutionModel::isAuthenticatorFlow)
			.findFirst();

		if (baseExecution.isEmpty()) {
			throw new IllegalStateException("This authenticator is only valid in combination with 2FA subflow");
		}
		return baseExecution.get();
	}

	private boolean isConditionalExecution(KeycloakSession session, AuthenticationExecutionModel e) {
		AuthenticatorFactory factory = (AuthenticatorFactory) session.getKeycloakSessionFactory()
			.getProviderFactory(Authenticator.class, e.getAuthenticator());
		if (factory != null) {
			Authenticator auth = factory.create(session);
			return (auth instanceof ConditionalAuthenticator);
		}
		return false;
	}

	/**
	 * Get required action provider for execution in flow
	 *
	 * @param context
	 * @param e
	 * @return
	 */
	private List<RequiredActionProviderModel> getRequiredActions(AuthenticationFlowContext context, AuthenticationExecutionModel e) {
		AuthenticatorFactory factory = (AuthenticatorFactory) context.getSession().getKeycloakSessionFactory()
			.getProviderFactory(Authenticator.class, e.getAuthenticator());
		Authenticator authenticator = factory.create(context.getSession());
		return authenticator.getRequiredActions(context.getSession())
			.stream()
			.map(f -> context.getRealm().getRequiredActionProviderByAlias(f.getId()))
			.filter(Objects::nonNull)
			.collect(Collectors.toList());
	}

	@Override
	public void action(AuthenticationFlowContext context) {
		MultivaluedMap<String, String> decodedFormParameters = context.getHttpRequest().getDecodedFormParameters();
		if(isSetupOptional(context.getAuthenticatorConfig()) && (!decodedFormParameters.containsKey(FORM_PARAM_MFA_METHOD) || decodedFormParameters.getFirst(FORM_PARAM_MFA_METHOD).isBlank())) {
			context.success();
			return;
		}

		if (!decodedFormParameters.containsKey(FORM_PARAM_MFA_METHOD)) {
			context.challenge(
				context.form().createErrorPage(Response.Status.BAD_REQUEST));
			context.failure(AuthenticationFlowError.CREDENTIAL_SETUP_REQUIRED);
			return;
		}

		String action = decodedFormParameters.getFirst(FORM_PARAM_MFA_METHOD);

		Stream<String> requiredActions = getAllRequiredActions(context).stream()
			.map(RequiredActionProviderModel::getProviderId);
		if (requiredActions.noneMatch(it -> it.equals(action))) {
			context.challenge(
				context.form().createErrorPage(Response.Status.BAD_REQUEST));
			context.failure(AuthenticationFlowError.CREDENTIAL_SETUP_REQUIRED);
			return;
		}

		AuthenticationSessionModel authenticationSession = context.getAuthenticationSession();
		if (!authenticationSession.getRequiredActions().contains(action)) {
			authenticationSession.addRequiredAction(action);
		}
		context.success();
	}

	private boolean isSetupOptional(AuthenticatorConfigModel config) {
		return Optional.ofNullable(config)
				.map(AuthenticatorConfigModel::getConfig)
				.map(c -> c.getOrDefault(CONFIG_OPTIONAL_NAME, String.valueOf(CONFIG_OPTIONAL_DEFAULT_VALUE)))
				.map(Boolean::parseBoolean)
				.orElse(CONFIG_OPTIONAL_DEFAULT_VALUE);
	}

	@Override
	public boolean requiresUser() {
		return true;
	}

	@Override
	public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
		AuthenticationFlowModel browserFlow = AuthenticationFlowResolver.resolveBrowserFlow(
			session.getContext().getAuthenticationSession()
		);

		List<AuthenticationExecutionModel> executions = realm
			.getAuthenticationExecutionsStream(browserFlow.getId())
			.collect(Collectors.toList());

		AuthenticationExecutionModel execution = null;

		for (int i = 0; i < executions.size(); i++) {
			execution = executions.get(i);
			if (execution.isAuthenticatorFlow()) {
				executions.addAll(realm
					.getAuthenticationExecutionsStream(execution.getFlowId())
					.toList());
			} else if (EnforceMfaAuthenticatorFactory.PROVIDER_ID.equals(execution.getAuthenticator())) {
				break;
			}
		}

		if (execution == null) {
			return false;
		}

		return getExecutions(session, realm, execution)
			.noneMatch(e -> isAuthenticatorConfiguredFor(session, realm, user, e));
	}

	private boolean isAuthenticatorConfiguredFor(KeycloakSession session, RealmModel realm, UserModel user, AuthenticationExecutionModel e) {
		AuthenticatorFactory factory = (AuthenticatorFactory) session.getKeycloakSessionFactory()
			.getProviderFactory(Authenticator.class, e.getAuthenticator());
		Authenticator authenticator = factory.create(session);
		return authenticator.configuredFor(session, realm, user);
	}

	@Override
	public void setRequiredActions(KeycloakSession keycloakSession, RealmModel realmModel, UserModel userModel) {

	}

	@Override
	public void close() {

	}
}

================
File: enforce-mfa/src/main/java/netzbegruenung/keycloak/enforce_mfa/EnforceMfaAuthenticatorFactory.java
================
package netzbegruenung.keycloak.enforce_mfa;

import org.keycloak.Config;
import org.keycloak.authentication.Authenticator;
import org.keycloak.authentication.AuthenticatorFactory;
import org.keycloak.models.AuthenticationExecutionModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;
import org.keycloak.provider.ProviderConfigProperty;
import org.keycloak.provider.ProviderConfigurationBuilder;

import java.util.List;

import static netzbegruenung.keycloak.enforce_mfa.EnforceMfaAuthenticator.CONFIG_OPTIONAL_DEFAULT_VALUE;
import static netzbegruenung.keycloak.enforce_mfa.EnforceMfaAuthenticator.CONFIG_OPTIONAL_NAME;

public class EnforceMfaAuthenticatorFactory implements AuthenticatorFactory {

	public static final String PROVIDER_ID = "enforce-mfa";

	private static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
		AuthenticationExecutionModel.Requirement.ALTERNATIVE,
		AuthenticationExecutionModel.Requirement.DISABLED,
		AuthenticationExecutionModel.Requirement.REQUIRED
	};
	@Override
	public String getDisplayType() {
		return "Enforce MFA";
	}

	@Override
	public String getReferenceCategory() {
		return null;
	}

	@Override
	public boolean isConfigurable() {
		return true;
	}

	@Override
	public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
		return REQUIREMENT_CHOICES;
	}

	@Override
	public boolean isUserSetupAllowed() {
		return false;
	}

	@Override
	public String getHelpText() {
		return "This authenticator must always be encapsulated in conditional subflow. Eligible choices must be configured by the first adjacent subflow.";
	}

	@Override
	public List<ProviderConfigProperty> getConfigProperties() {
		return ProviderConfigurationBuilder.create()
										   .property().name(CONFIG_OPTIONAL_NAME).label("MFA setup is optional").helpText("Users can skip the setup of MFA").type(ProviderConfigProperty.BOOLEAN_TYPE).defaultValue(CONFIG_OPTIONAL_DEFAULT_VALUE)
										   .add().build();
	}

	@Override
	public Authenticator create(KeycloakSession keycloakSession) {
		return new EnforceMfaAuthenticator();
	}

	@Override
	public void init(Config.Scope scope) {

	}

	@Override
	public void postInit(KeycloakSessionFactory keycloakSessionFactory) {

	}

	@Override
	public void close() {

	}

	@Override
	public String getId() {
		return PROVIDER_ID;
	}
}

================
File: enforce-mfa/src/main/resources/META-INF/services/org.keycloak.authentication.AuthenticatorFactory
================
netzbegruenung.keycloak.enforce_mfa.EnforceMfaAuthenticatorFactory

================
File: enforce-mfa/src/main/resources/theme-resources/messages/messages_de.properties
================
loginChooseMfa=Bitte wähle eine Authentisieriungs-Methode als zweiten Faktor.
enforceMfa.webauthn-register=Passkey/FIDO2
enforceMfa.webauthn-register-help-text=Nutze einen Passkey oder FIDO2 USB Token. Diese Methode bringt die größte Sicherheit.
enforceMfa.CONFIGURE_TOTP=TOTP App
enforceMfa.CONFIGURE_TOTP-help-text=Gib einen 6-stelligen Code ein, der in einer Smartphone-App generiert wird.
enforceMfa.app-register=Authentisierungs-App
enforceMfa.app-register-help-text=Bestätige die Anmeldung auf einer zusätzlichen Authentisierungs-App.
enforceMfa.mobile_number_config=SMS Code
enforceMfa.mobile_number_config-help-text=Empfange eine Bestätigungscode via SMS.
enforceMfa.skipSetup=Später konfigurieren
enforceMfaIllegalState=Ein Fehler ist aufgetreten. Bitte kontaktiere einen oder eine Administratorin.

================
File: enforce-mfa/src/main/resources/theme-resources/messages/messages_en.properties
================
loginChooseMfa=Please choose an authentication method as a second factor.
enforceMfa.webauthn-register=Passkey/FIDO2
enforceMfa.webauthn-register-help-text=Use a Passkey or USB FIDO2 token. This provides the highest security.
enforceMfa.CONFIGURE_TOTP=TOTP App
enforceMfa.CONFIGURE_TOTP-help-text=Enter a 6-digit verification code that is generated on a smartphone app.
enforceMfa.app-register=Authentication App
enforceMfa.app-register-help-text=Use an app to confirm your login.
enforceMfa.mobile_number_config=SMS Code
enforceMfa.mobile_number_config-help-text=Receive a confirmation code via SMS.
enforceMfa.skipSetup=Skip configuration
enforceMfaIllegalState=An error occurred. Please contact an administrator.

================
File: enforce-mfa/src/main/resources/theme-resources/templates/enforce-mfa.ftl
================
<#import "template.ftl" as layout>
<@layout.registrationLayout displayInfo=true; section>
    <#if section = "header" || section = "show-username">
		<script type="text/javascript">
			function fillAndSubmit(authExecId) {
				document.getElementById('mfa-method-hidden-input').value = authExecId;
				document.getElementById('kc-select-mfa-form').submit();
			}
		</script>
        <#if section = "header">
            ${msg("loginChooseMfa")}
        </#if>
    <#elseif section = "form">

		<form id="kc-select-mfa-form" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
			<div class="${properties.kcSelectAuthListClass!}">
                <#list mfa! as requiredAction>
					<div class="${properties.kcSelectAuthListItemClass!}" onclick="fillAndSubmit('${requiredAction.providerId}')" id="mfa-${requiredAction.providerId}" style="cursor: pointer;">

						<div class="${properties.kcSelectAuthListItemIconClass!}">
							<i class="${properties.kcSelectAuthListItemIconPropertyClass!} ${properties.kcAuthenticatorDefaultClass!}"></i>
						</div>
						<div class="${properties.kcSelectAuthListItemBodyClass!}">
							<div class="${properties.kcSelectAuthListItemHeadingClass!}">
                                ${msg('${localizationPrefix}.${requiredAction.providerId}')}
							</div>
							<div class="${properties.kcSelectAuthListItemDescriptionClass!}">
                                ${msg('${localizationPrefix}.${requiredAction.providerId}-help-text')}
							</div>
						</div>
					</div>
                </#list>
				<input type="hidden" id="mfa-method-hidden-input" name="mfaMethod" />
			</div>
		</form>
	<#elseif section = "info">
		${msg("loginChooseMfa")}

		<#if isSetupOptional = true>
			<br/>
			<a href="#" onclick="event.preventDefault(); fillAndSubmit('')">${msg("${localizationPrefix}.skipSetup")}</a>
		</#if>
    </#if>
</@layout.registrationLayout>

================
File: enforce-mfa/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
		 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>netzbegruenung</groupId>
		<artifactId>keycloak-mfa-tools</artifactId>
		<version>26.1.2</version>
	</parent>

	<artifactId>enforce-mfa</artifactId>

	<dependencies>
		<dependency>
			<groupId>org.keycloak</groupId>
			<artifactId>keycloak-quarkus-server-app</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- Necessary for proper execution of IDELauncher -->
		<!-- Can be removed as part of the https://github.com/keycloak/keycloak/issues/22455 enhancement -->
		<dependency>
			<groupId>io.quarkus</groupId>
			<artifactId>quarkus-vertx-http-dev-ui-resources</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- this dependency is necessary to start the IDELauncher -->
		<dependency>
			<groupId>com.oracle.database.jdbc</groupId>
			<artifactId>ojdbc11</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- https://github.com/keycloak/keycloak/issues/34549 -->
		<dependency>
			<groupId>io.mvnpm</groupId>
			<artifactId>importmap</artifactId>
			<scope>provided</scope>
		</dependency>
	</dependencies>

	<build>
		<finalName>${project.groupId}.${project.artifactId}-v${project.version}</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-surefire-plugin</artifactId>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
			</plugin>
			<plugin>
				<groupId>io.quarkus</groupId>
				<artifactId>quarkus-maven-plugin</artifactId>
				<configuration>
					<argsString>start-dev --db-url jdbc:h2:file:${project.parent.basedir}/h2db/enforce;AUTO_SERVER=TRUE;NON_KEYWORDS=VALUE</argsString>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>

================
File: enforce-mfa/README.md
================
# Enforce MFA Authenticator

Implementation of an MFA enforcement authenticator. After successful setup like described below the authenticator detects
user with no second factor enabled and allows to choose a MFA method available in the current flow.

This implementation should not be confused with the ability to choose default MFA credentials, a feature which must be
supported by the account console. For further information see https://github.com/keycloak/keycloak/issues/14340

## Scope of this authenticator

This authenticator is an intermediate solution until keycloak can support flow configuration like the following:

```
- 2ndlevel-subflow REQUIRED
-- OTP ALTERNATIVE
-- WebAuthn ALTERNATIVE
```

The expected behaviour is, that the user either authenticates by one of the listed authenticators or chooses to set up
one of them.
Actual behaviour is an authentication flow exception, when no MFA method is available.

See: https://github.com/keycloak/keycloak/discussions/19548

## How to use this authenticator

This authenticator **must always** be used with an authentication flow like the following:

```
- MFA Wrapper Flow
-- MFA-Authenticate-subflow CONDITIONAL
--- Condition - user configured REQUIRED
--- OTP ALTERNATIVE
--- WebAuthn ALTERNATIVE

-- Register-MFA-subflow CONDITIONAL
--- Condition - user configured REQUIRED
--- Enforce-MFA REQUIRED
```

The expected flow must contain at least two subflows. The subflow, which contains the alternatives for MFA
**must be the first subflow in its wrapper flow**.

Example:

![Example Configuration](Enforce-MFA.png)

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/credentials/SmsAuthCredentialData.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * @author <a href="mailto:alistair.doswald@elca.ch">Alistair Doswald</a>
 * @version $Revision: 1 $
 */

package netzbegruenung.keycloak.authenticator.credentials;

import com.fasterxml.jackson.annotation.JsonProperty;

public class SmsAuthCredentialData {

	private final String mobileNumber;

	//@JsonCreator
	public SmsAuthCredentialData(@JsonProperty("mobile_number") String mobileNumber) {
		this.mobileNumber = mobileNumber;
	}

	public String getMobileNumber() {
		return mobileNumber;
	}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/credentials/SmsAuthCredentialModel.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:alistair.doswald@elca.ch">Alistair Doswald</a>
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator.credentials;

import org.keycloak.common.util.Time;
import org.keycloak.credential.CredentialModel;
import org.keycloak.util.JsonSerialization;

import java.io.IOException;

public class SmsAuthCredentialModel extends CredentialModel {
	public static final String TYPE = "mobile-number";

	private final SmsAuthCredentialData mobileNumber;


	private SmsAuthCredentialModel(SmsAuthCredentialData mobileNumber) {
		this.mobileNumber = mobileNumber;
	}

	private SmsAuthCredentialModel(String mobileNumberString) {
		mobileNumber = new SmsAuthCredentialData(mobileNumberString);
	}

	public static SmsAuthCredentialModel createFromModel(CredentialModel credentialModel){
		try {
			SmsAuthCredentialData credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(), SmsAuthCredentialData.class);

			SmsAuthCredentialModel smsAuthenticatorModel = new SmsAuthCredentialModel(credentialData);
			smsAuthenticatorModel.setUserLabel(
					"Mobile Number: ***" + credentialData.getMobileNumber().substring(
							Math.max(credentialData.getMobileNumber().length() - 3, 0)
					)
			);
			smsAuthenticatorModel.setCreatedDate(credentialModel.getCreatedDate());
			smsAuthenticatorModel.setType(TYPE);
			smsAuthenticatorModel.setId(credentialModel.getId());
			smsAuthenticatorModel.setCredentialData(credentialModel.getCredentialData());
			return smsAuthenticatorModel;
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}


	public static SmsAuthCredentialModel createSmsAuthenticator(String mobileNumber) {
		SmsAuthCredentialModel credentialModel = new SmsAuthCredentialModel(mobileNumber);
		credentialModel.fillCredentialModelFields();
		return credentialModel;
	}

	public SmsAuthCredentialData getSmsAuthenticatorData() {
		return mobileNumber;
	}

	private void fillCredentialModelFields(){
		try {
			setCredentialData(JsonSerialization.writeValueAsString(mobileNumber));
			setType(TYPE);
			setCreatedDate(Time.currentTimeMillis());
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/gateway/ApiSmsService.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author Niko Köbler, https://www.n-k.de, @dasniko
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator.gateway;

import java.util.Map;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpRequest.Builder;
import java.net.http.HttpResponse;
import org.jboss.logging.Logger;
import java.util.Base64;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.util.Optional;
import java.util.regex.Pattern;

public class ApiSmsService implements SmsService{

	private static final Logger logger = Logger.getLogger(SmsServiceFactory.class);
	private static final Pattern plusPrefixPattern = Pattern.compile("\\+");

	private final String apiurl;
	private final Boolean urlencode;

	private final String apitoken;
	private final String apiuser;

	private final String senderId;
	private final String countrycode;

	private final String apitokenattribute;
	private final String messageattribute;
	private final String receiverattribute;
	private final String receiverJsonTemplate;
	private final String senderattribute;

	private final boolean hideResponsePayload;

	ApiSmsService(Map<String, String> config) {
		apiurl = config.get("apiurl");
		urlencode = Boolean.parseBoolean(config.getOrDefault("urlencode", "false"));

		apitoken = config.getOrDefault("apitoken", "");
		apiuser = config.getOrDefault("apiuser", "");

		countrycode = config.getOrDefault("countrycode", "");
		senderId = config.get("senderId");

		apitokenattribute = config.getOrDefault("apitokenattribute", "");
		messageattribute = config.get("messageattribute");
		receiverattribute = config.get("receiverattribute");
		receiverJsonTemplate = config.getOrDefault("receiverJsonTemplate", "\"%s\"");
		senderattribute = config.get("senderattribute");

		hideResponsePayload = Boolean.parseBoolean(config.get("hideResponsePayload"));
	}

	public void send(String phoneNumber, String message) {
		phoneNumber = clean_phone_number(phoneNumber, countrycode);
		Builder request_builder;
		HttpRequest request = null;
		var client = HttpClient.newHttpClient();
		try {
			if (urlencode) {
				request_builder = urlencoded_request(phoneNumber, message);
			} else {
				request_builder = json_request(phoneNumber, message);
			}
			if (apiuser != null && !apiuser.isEmpty()) {
				request = request_builder.setHeader("Authorization", get_auth_header(apiuser, apitoken)).build();
			} else {
				request = request_builder.build();
			}
			HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());

			int statusCode = response.statusCode();
			String payload = hideResponsePayload ? "redacted" : "Response: " + response.body();

			if (statusCode >= 200 && statusCode < 300) {
				logger.infof("Sent SMS to %s [%s]", phoneNumber, payload);
			} else {
				logger.errorf("Failed to send message to %s [%s]. Validate your config.", phoneNumber, payload);
			}
		} catch (Exception e) {
			logger.errorf(e, "Failed to send message to %s with request: %s. Validate your config.", phoneNumber, request != null ? request.toString() : "null");
		}
	}

	public Builder json_request(String phoneNumber, String message) {
		String sendJson = "{"
						  + Optional.ofNullable(apitokenattribute)..filter(attr -> !attr.trim().isEmpty()).map(it -> String.format("\"%s\":\"%s\",", it, apitoken)).orElse("")
						  + String.format("\"%s\":\"%s\",", messageattribute, message)
						  + String.format("\"%s\":%s,", receiverattribute, String.format(receiverJsonTemplate, phoneNumber))
						  + String.format("\"%s\":\"%s\"", senderattribute, senderId)
						  + "}";

		 return HttpRequest.newBuilder()
			.uri(URI.create(apiurl))
			.header("Content-Type", "application/json")
			.POST(HttpRequest.BodyPublishers.ofString(sendJson));
	}

	public Builder urlencoded_request(String phoneNumber, String message) {
		String body = Optional.ofNullable(apitokenattribute)
						  .map(it -> String.format("%s=%s&", it, URLEncoder.encode(apitoken, Charset.defaultCharset()))).orElse("")
					  + String.format("%s=%s&", messageattribute, URLEncoder.encode(message, Charset.defaultCharset()))
					  + String.format("%s=%s&", receiverattribute, URLEncoder.encode(phoneNumber, Charset.defaultCharset()))
					  + String.format("%s=%s", senderattribute, URLEncoder.encode(senderId, Charset.defaultCharset()));

		return HttpRequest.newBuilder()
				.uri(URI.create(apiurl))
				.header("Content-Type", "application/x-www-form-urlencoded")
				.POST(HttpRequest.BodyPublishers.ofString(body));
	}

	private static String get_auth_header(String apiuser, String apitoken) {
		String authString = apiuser + ':' + apitoken;
		String b64_cred = Base64.getEncoder().encodeToString(authString.getBytes());
		return "Basic " + b64_cred;
	}

	private static String clean_phone_number(String phone_number, String countrycode) {
		/*
		 * This function tries to correct several common user errors. If there is no default country
		 * prefix, this function does not dare to touch the phone number.
		 * https://en.wikipedia.org/wiki/List_of_mobile_telephone_prefixes_by_country
		 */
		if (countrycode == null || countrycode.isEmpty()) {
			logger.infof("Clean phone number: no country code set, return %s", phone_number);
			return phone_number;
		}
		String country_number = plusPrefixPattern.matcher(countrycode).replaceFirst("");
		// convert 49 to +49
		if (phone_number.startsWith(country_number)) {
			phone_number = phone_number.replaceFirst(country_number, countrycode);
			logger.infof("Clean phone number: convert 49 to +49, set phone number to %s", phone_number);
		}
		// convert 0049 to +49
		if (phone_number.startsWith("00" + country_number)) {
			phone_number = phone_number.replaceFirst("00" + country_number, countrycode);
			logger.infof("Clean phone number: convert 0049 to +49, set phone number to %s", phone_number);
		}
		// convert +490176 to +49176
		if (phone_number.startsWith(countrycode + '0')) {
			phone_number = phone_number.replaceFirst("\\+" + country_number + '0', countrycode);
			logger.infof("Clean phone number: convert +490176 to +49176, set phone number to %s", phone_number);
		}
		// convert 0 to +49
		if (phone_number.startsWith("0")) {
			phone_number = phone_number.replaceFirst("0", countrycode);
			logger.infof("Clean phone number: convert 0 to +49, set phone number to %s", phone_number);
		}
		return phone_number;
	}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/gateway/SmsService.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author Niko Köbler, https://www.n-k.de, @dasniko
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator.gateway;

public interface SmsService {

	void send(String phoneNumber, String message);

}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/gateway/SmsServiceFactory.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author Niko Köbler, https://www.n-k.de, @dasniko
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator.gateway;

import org.jboss.logging.Logger;

import java.util.Map;

public class SmsServiceFactory {

	private static final Logger logger = Logger.getLogger(SmsServiceFactory.class);

	public static SmsService get(Map<String, String> config) {
		if (Boolean.parseBoolean(config.getOrDefault("simulation", "false"))) {
			return (phoneNumber, message) ->
				logger.infof("***** SIMULATION MODE ***** Would send SMS to %s with text: %s", phoneNumber, message);
		} else {
			return new ApiSmsService(config);
		}
	}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/PhoneNumberRequiredAction.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator;

import com.google.common.base.Splitter;
import com.google.i18n.phonenumbers.NumberParseException;
import com.google.i18n.phonenumbers.PhoneNumberUtil;
import com.google.i18n.phonenumbers.Phonenumber.PhoneNumber;
import jakarta.ws.rs.core.Response;
import netzbegruenung.keycloak.authenticator.credentials.SmsAuthCredentialModel;
import org.jboss.logging.Logger;
import org.keycloak.authentication.CredentialRegistrator;
import org.keycloak.authentication.InitiatedActionSupport;
import org.keycloak.authentication.RequiredActionContext;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.authentication.requiredactions.WebAuthnRegisterFactory;
import org.keycloak.credential.CredentialModel;
import org.keycloak.models.AuthenticatorConfigModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RoleModel;
import org.keycloak.models.UserModel;
import org.keycloak.models.credential.OTPCredentialModel;
import org.keycloak.models.credential.WebAuthnCredentialModel;
import org.keycloak.sessions.AuthenticationSessionModel;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Stream;

public class PhoneNumberRequiredAction implements RequiredActionProvider, CredentialRegistrator {

	public static final String PROVIDER_ID = "mobile_number_config";

	private static final Logger logger = Logger.getLogger(PhoneNumberRequiredAction.class);
	private static final Splitter numberFilterSplitter = Splitter.on("##");
	private static final Pattern nonDigitPattern = Pattern.compile("[^0-9+]");
	private static final Pattern whitespacePattern = Pattern.compile("\\s+");

	@Override
	public InitiatedActionSupport initiatedActionSupport() {
		return InitiatedActionSupport.SUPPORTED;
	}

	@Override
	public void evaluateTriggers(RequiredActionContext context) {
		// TODO: get the alias from somewhere else or move config into realm or application scope
		AuthenticatorConfigModel config = context.getRealm().getAuthenticatorConfigByAlias("sms-2fa");
		if (config == null) {
			logger.error("Failed to check 2FA enforcement, no config alias sms-2fa found");
			return;
		}
		boolean forceSecondFactorEnabled = Boolean.parseBoolean(config.getConfig().get("forceSecondFactor"));
		if (forceSecondFactorEnabled) {
			if (config.getConfig().get("whitelist") != null) {
				RoleModel whitelistRole = context.getRealm().getRole(config.getConfig().get("whitelist"));
				if (whitelistRole == null) {
					logger.errorf(
						"Failed configured whitelist role check [%s], make sure that the role exists",
						config.getConfig().get("whitelist")
					);
				} else if (context.getUser().hasRole(whitelistRole)) {
					// skip enforcement if user is whitelisted
					return;
				}
			}
			// add auth note for phone number input placeholder
			context.getAuthenticationSession().setAuthNote("mobileInputFieldPlaceholder",
				config.getConfig().getOrDefault("mobileInputFieldPlaceholder", ""));

			// list of accepted 2FA alternatives
			List<String> secondFactors = Arrays.asList(
				SmsAuthCredentialModel.TYPE,
				WebAuthnCredentialModel.TYPE_TWOFACTOR,
				OTPCredentialModel.TYPE
			);
			Stream<CredentialModel> credentials = context
				.getUser()
				.credentialManager()
				.getStoredCredentialsStream();
			if (credentials.anyMatch(x -> secondFactors.contains(x.getType()))) {
				// skip as 2FA is already set
				return;
			}

			Set<String> availableRequiredActions = Set.of(
				PhoneNumberRequiredAction.PROVIDER_ID,
				PhoneValidationRequiredAction.PROVIDER_ID,
				UserModel.RequiredAction.CONFIGURE_TOTP.name(),
				WebAuthnRegisterFactory.PROVIDER_ID,
				UserModel.RequiredAction.UPDATE_PASSWORD.name()
			);
			Set<String> authSessionRequiredActions = context.getAuthenticationSession().getRequiredActions();
			authSessionRequiredActions.retainAll(availableRequiredActions);
			if (!authSessionRequiredActions.isEmpty()) {
				// skip as relevant required action is already set
				return;
			}

			Stream<String> usersRequiredActions = context.getUser().getRequiredActionsStream();
			if (usersRequiredActions.noneMatch(availableRequiredActions::contains)) {
				logger.infof(
					"No 2FA method configured for user: %s, setting required action for SMS authenticator",
					context.getUser().getUsername()
				);
				context.getUser().addRequiredAction(PhoneNumberRequiredAction.PROVIDER_ID);
			}
		}
	}

	@Override
	public void requiredActionChallenge(RequiredActionContext context) {
		Response challenge = context.form()
			.setAttribute("mobileInputFieldPlaceholder", context.getAuthenticationSession().getAuthNote("mobileInputFieldPlaceholder"))
			.createForm("mobile_number_form.ftl");
		context.challenge(challenge);
	}

	@Override
	public void processAction(RequiredActionContext context) {
		String mobileNumber = nonDigitPattern.matcher(context.getHttpRequest().getDecodedFormParameters().getFirst("mobile_number")).replaceAll("");
		AuthenticationSessionModel authSession = context.getAuthenticationSession();

		// get the phone number formatting values from the config
		AuthenticatorConfigModel config = context.getRealm().getAuthenticatorConfigByAlias("sms-2fa");
		boolean normalizeNumber = false;
		boolean forceRetryOnBadFormat = false;
		if (config != null && config.getConfig() != null) {
			normalizeNumber = Boolean.parseBoolean(config.getConfig().getOrDefault("normalizePhoneNumber", "false"));
			forceRetryOnBadFormat = Boolean.parseBoolean(config.getConfig().getOrDefault("forceRetryOnBadFormat", "false"));
		}

		// try to format the phone number
		if (normalizeNumber) {
			String formattedNumber = formatPhoneNumber(context, mobileNumber);
			if (formattedNumber != null && !formattedNumber.isBlank()) {
				mobileNumber = formattedNumber;
			} else if (forceRetryOnBadFormat) {
				logger.errorf("Failed phone number formatting checks for: %s", mobileNumber);
				String formatError = context.getAuthenticationSession().getAuthNote("formatError");
				if (formatError != null && !formatError.isBlank()) {
					handleInvalidNumber(context, formatError);
					return;
				}
			}
		}

		authSession.setAuthNote("mobile_number", mobileNumber);
		logger.infof("Add required action for phone validation: [%s], user: %s", mobileNumber, context.getUser().getUsername());
		context.getAuthenticationSession().addRequiredAction(PhoneValidationRequiredAction.PROVIDER_ID);
		context.success();
	}

	/**
	 * Formats the provided mobile phone number to E164 standard.
	 *
	 * @param context		the current RequiredActionContext
	 * @param mobileNumber	the mobile phone number to be formatted
	 * @return				the formatted mobile phone number, null if the phone number is invalid or mobileNumber if the config was not found
	 */
	private String formatPhoneNumber(RequiredActionContext context, String mobileNumber) {
		AuthenticatorConfigModel config = context.getRealm().getAuthenticatorConfigByAlias("sms-2fa");
		if (config == null || config.getConfig() == null) {
			logger.error("Failed format phone number, no config alias sms-2fa found");
			return mobileNumber;
		}
		final PhoneNumberUtil phoneNumberUtil = PhoneNumberUtil.getInstance();
		int countryNumber;
		// try to get the country code from the country number in the config, fallback on default DE
		try {
			countryNumber = Integer.parseInt(whitespacePattern.matcher(config.getConfig()
				.getOrDefault("countrycode", "49").replace("+", ""))
				.replaceAll(""));
		} catch (NumberFormatException e) {
			logger.warn("Failed to parse countrycode to int, using default value (49)", e);
			countryNumber = 49;
		}
		String nameCodeToUse = phoneNumberUtil.getRegionCodeForCountryCode(countryNumber);
		PhoneNumber originalPhoneNumberParsed;

		// parse the mobile number and store it as instance of PhoneNumber
		try {
			originalPhoneNumberParsed = phoneNumberUtil.parse(mobileNumber, nameCodeToUse);
		} catch (NumberParseException e) {
			logger.error("Failed to parse phone number", e);
			context.getAuthenticationSession().setAuthNote("formatError", "numberFormatFailedToParse");
			return null;
		}

		if (!phoneNumberUtil.isValidNumber(originalPhoneNumberParsed)) {
			logger.error("Phone number is not valid");
			context.getAuthenticationSession().setAuthNote("formatError", "numberFormatNumberInvalid");
			return null;
		}

		// apply ValidNumberType filters
		// try to extract number types from filter string
		List<PhoneNumberUtil.PhoneNumberType> numberTypeFilters = new ArrayList<>();
		String numberFiltersString = null;
		try {
			numberFiltersString = config.getConfig().getOrDefault("numberTypeFilters", "");
			if (!numberFiltersString.isBlank()) {
				numberFilterSplitter.splitToStream(numberFiltersString).forEach(filterString ->
					numberTypeFilters.add(PhoneNumberUtil.PhoneNumberType.valueOf(filterString)));
			}
		} catch (Exception e) {
			// if the number type filter configuration is bad, log an error and continue without filtering
			logger.errorf("Illegal filter found: %s. Filter must be a list of comma delimited Strings of FIXED_LINE, MOBILE, "
				+ "FIXED_LINE_OR_MOBILE, PAGER, TOLL_FREE, PREMIUM_RATE, SHARED_COST, PERSONAL_NUMBER, VOIP, UAN, VOICEMAIL", numberFiltersString);
			numberTypeFilters.clear();
		}

		// check to see if the number type matches any of the filters set
		if (!numberTypeFilters.isEmpty()) {
			PhoneNumberUtil.PhoneNumberType numberType = phoneNumberUtil.getNumberType(originalPhoneNumberParsed);
			if (numberTypeFilters.stream().noneMatch(filter -> filter == numberType)) {
				logger.errorf("Phone number type %s does not match any filters in %s", numberType.toString(), numberTypeFilters);
				context.getAuthenticationSession().setAuthNote("formatError", "numberFormatNoMatchingFilters");
				return null;
			}
		}

		// return the E164 format of the mobile number
		return phoneNumberUtil.format(originalPhoneNumberParsed, PhoneNumberUtil.PhoneNumberFormat.E164);
	}

	private void handleInvalidNumber(RequiredActionContext context, String formatError) {
		Response challenge = context
			.form()
			.setAttribute("mobileInputFieldPlaceholder", context.getAuthenticationSession().getAuthNote("mobileInputFieldPlaceholder"))
			.setError(formatError)
			.createForm("mobile_number_form.ftl");
		context.challenge(challenge);
	}

	@Override
	public void close() {}

	@Override
	public String getCredentialType(KeycloakSession keycloakSession, AuthenticationSessionModel authenticationSessionModel) {
		return SmsAuthCredentialModel.TYPE;
	}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/PhoneNumberRequiredActionFactory.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator;

import org.keycloak.Config;
import org.keycloak.authentication.RequiredActionFactory;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;

/**
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @version $Revision: 1 $
 */
public class PhoneNumberRequiredActionFactory implements RequiredActionFactory {

    private static final PhoneNumberRequiredAction SINGLETON = new PhoneNumberRequiredAction();

    @Override
    public RequiredActionProvider create(KeycloakSession session) {
        return SINGLETON;
    }

    @Override
    public String getId() {
        return PhoneNumberRequiredAction.PROVIDER_ID;
    }

    @Override
    public String getDisplayText() {
        return "Update Mobile Number";
    }

    @Override
    public void init(Config.Scope config) {

    }

    @Override
    public void postInit(KeycloakSessionFactory factory) {

    }

    @Override
    public void close() {

    }

}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/PhoneValidationRequiredAction.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @author Niko Köbler, https://www.n-k.de, @dasniko
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator;

import netzbegruenung.keycloak.authenticator.credentials.SmsAuthCredentialModel;
import netzbegruenung.keycloak.authenticator.gateway.SmsServiceFactory;

import org.jboss.logging.Logger;
import org.keycloak.authentication.CredentialRegistrator;
import org.keycloak.authentication.RequiredActionContext;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.common.util.SecretGenerator;
import org.keycloak.credential.CredentialProvider;
import org.keycloak.models.AuthenticatorConfigModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserCredentialModel;
import org.keycloak.models.UserModel;
import org.keycloak.sessions.AuthenticationSessionModel;
import org.keycloak.theme.Theme;

import java.util.Locale;
import jakarta.ws.rs.core.Response;

public class PhoneValidationRequiredAction implements RequiredActionProvider, CredentialRegistrator {
	private static final Logger logger = Logger.getLogger(PhoneValidationRequiredAction.class);
	public static final String PROVIDER_ID = "phone_validation_config";

	@Override
	public void evaluateTriggers(RequiredActionContext context) {
	}

	@Override
	public void requiredActionChallenge(RequiredActionContext context) {
		context.getUser().addRequiredAction(PhoneNumberRequiredAction.PROVIDER_ID);
		try {
			UserModel user = context.getUser();
			RealmModel realm = context.getRealm();

			AuthenticationSessionModel authSession = context.getAuthenticationSession();
			// TODO: get the alias from somewhere else or move config into realm or application scope
			AuthenticatorConfigModel config = context.getRealm().getAuthenticatorConfigByAlias("sms-2fa");

			String mobileNumber = authSession.getAuthNote("mobile_number");
			logger.infof("Validating phone number: %s of user: %s", mobileNumber, user.getUsername());

			int length = Integer.parseInt(config.getConfig().get("length"));
			int ttl = Integer.parseInt(config.getConfig().get("ttl"));

			String code = SecretGenerator.getInstance().randomString(length, SecretGenerator.DIGITS);
			authSession.setAuthNote("code", code);
			authSession.setAuthNote("ttl", Long.toString(System.currentTimeMillis() + (ttl * 1000L)));

			Theme theme = context.getSession().theme().getTheme(Theme.Type.LOGIN);
			Locale locale = context.getSession().getContext().resolveLocale(user);
			String smsAuthText = theme.getEnhancedMessages(realm,locale).getProperty("smsAuthText");
			String smsText = String.format(smsAuthText, code, Math.floorDiv(ttl, 60));

			SmsServiceFactory.get(config.getConfig()).send(mobileNumber, smsText);

			Response challenge = context.form()
				.setAttribute("realm", realm)
				.createForm("login-sms.ftl");
			context.challenge(challenge);
		} catch (Exception e) {
			logger.error(e.getMessage(), e);
			context.failure();
		}
	}

	@Override
	public void processAction(RequiredActionContext context) {
		String enteredCode = context.getHttpRequest().getDecodedFormParameters().getFirst("code");

		AuthenticationSessionModel authSession = context.getAuthenticationSession();
		String mobileNumber = authSession.getAuthNote("mobile_number");
		String code = authSession.getAuthNote("code");
		String ttl = authSession.getAuthNote("ttl");

		if (code == null || ttl == null || enteredCode == null) {
			logger.warn("Phone number is not set");
			handleInvalidSmsCode(context);
			return;
		}

		boolean isValid = enteredCode.equals(code);
		if (isValid && Long.parseLong(ttl) > System.currentTimeMillis()) {
			// valid
			SmsAuthCredentialProvider smnp = (SmsAuthCredentialProvider) context.getSession().getProvider(CredentialProvider.class, "mobile-number");
			if (!smnp.isConfiguredFor(context.getRealm(), context.getUser(), SmsAuthCredentialModel.TYPE)) {
				smnp.createCredential(context.getRealm(), context.getUser(), SmsAuthCredentialModel.createSmsAuthenticator(mobileNumber));
			} else {
				smnp.updateCredential(
					context.getRealm(),
					context.getUser(),
					new UserCredentialModel("random_id", "mobile-number", mobileNumber)
				);
			}
			context.getUser().removeRequiredAction(PhoneNumberRequiredAction.PROVIDER_ID);
			handlePhoneToAttribute(context, mobileNumber);
			context.success();
		} else {
			// invalid or expired
			handleInvalidSmsCode(context);
		}
	}

	private void handlePhoneToAttribute(RequiredActionContext context, String mobileNumber) {
		AuthenticatorConfigModel config = context.getRealm().getAuthenticatorConfigByAlias("sms-2fa");
		if (config == null) {
			logger.warn("No config alias sms-2fa found, skip phone number to attribute check");
		} else {
			if (Boolean.parseBoolean(config.getConfig().get("storeInAttribute"))) {
				context.getUser().setSingleAttribute("mobile_number", mobileNumber);
			}
		}
	}

	private void handleInvalidSmsCode(RequiredActionContext context) {
		Response challenge = context
			.form()
			.setAttribute("realm", context.getRealm())
			.setError("smsAuthCodeInvalid")
			.createForm("login-sms.ftl");
		context.challenge(challenge);
	}

	@Override
	public void close() {
	}

	@Override
	public String getCredentialType(KeycloakSession keycloakSession, AuthenticationSessionModel authenticationSessionModel) {
		return SmsAuthCredentialModel.TYPE;
	}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/PhoneValidationRequiredActionFactory.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @author Niko Köbler, https://www.n-k.de, @dasniko
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator;

import org.keycloak.Config;
import org.keycloak.authentication.RequiredActionFactory;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;

public class PhoneValidationRequiredActionFactory implements RequiredActionFactory {

    private static final PhoneValidationRequiredAction SINGLETON = new PhoneValidationRequiredAction();

    @Override
    public RequiredActionProvider create(KeycloakSession session) {
        return SINGLETON;
    }


    @Override
    public String getId() {
        return PhoneValidationRequiredAction.PROVIDER_ID;
    }

    @Override
    public String getDisplayText() {
        return "Phone Validation";
    }

    @Override
    public void init(Config.Scope config) {

    }

    @Override
    public void postInit(KeycloakSessionFactory factory) {

    }

    @Override
    public void close() {

    }

}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/SmsAuthCredentialProvider.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator;

import netzbegruenung.keycloak.authenticator.credentials.SmsAuthCredentialModel;
import org.keycloak.common.util.Time;
import org.keycloak.credential.CredentialInput;
import org.keycloak.credential.CredentialInputUpdater;
import org.keycloak.credential.CredentialInputValidator;
import org.keycloak.credential.CredentialModel;
import org.keycloak.credential.CredentialProvider;
import org.keycloak.credential.CredentialTypeMetadata;
import org.keycloak.credential.CredentialTypeMetadataContext;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserCredentialModel;
import org.keycloak.models.UserModel;
import java.util.*;
import java.util.stream.Stream;

public class SmsAuthCredentialProvider implements CredentialProvider<SmsAuthCredentialModel>, CredentialInputValidator, CredentialInputUpdater {

    protected final KeycloakSession session;

    public SmsAuthCredentialProvider(KeycloakSession session) {
        this.session = session;
    }

    @Override
    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
        if (!(input instanceof UserCredentialModel)) {
            return false;
        }
        if (!input.getType().equals(getType())) {
            return false;
        }
        String challengeResponse = input.getChallengeResponse();
        if (challengeResponse == null) {
            return false;
        }
        CredentialModel credentialModel = user.credentialManager().getStoredCredentialById(input.getCredentialId());
        SmsAuthCredentialModel sqcm = getCredentialFromModel(credentialModel);
        return sqcm.getSmsAuthenticatorData().getMobileNumber().equals(challengeResponse);
    }

    @Override
    public boolean supportsCredentialType(String credentialType) {
        return getType().equals(credentialType);
    }

    @Override
    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
        if (!supportsCredentialType(credentialType)) return false;
        return user.credentialManager().getStoredCredentialsByTypeStream(credentialType).findAny().isPresent();
    }

    @Override
    public CredentialModel createCredential(RealmModel realm, UserModel user, SmsAuthCredentialModel credentialModel) {
        credentialModel.setCreatedDate(Time.currentTimeMillis());
        return user.credentialManager().createStoredCredential(credentialModel);
    }

    @Override
    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
        String mobileNumber = input.getChallengeResponse();
        Optional<CredentialModel> model = user.credentialManager().getStoredCredentialsByTypeStream(input.getType()).findFirst();
        if (model.isPresent()) {
            CredentialModel credentialModel = model.get();
            deleteCredential(realm, user, credentialModel.getId());
            createCredential(realm, user, SmsAuthCredentialModel.createSmsAuthenticator(mobileNumber));
            return true;
        } else {
            return false;
        }
    }

    @Override
    public boolean deleteCredential(RealmModel realm, UserModel user, String credentialId) {
        return user.credentialManager().removeStoredCredentialById(credentialId);
    }

    @Override
    public SmsAuthCredentialModel getCredentialFromModel(CredentialModel model) {
        return SmsAuthCredentialModel.createFromModel(model);
    }

    @Override
    public CredentialTypeMetadata getCredentialTypeMetadata(CredentialTypeMetadataContext metadataContext) {
        return CredentialTypeMetadata.builder()
                .type(getType())
                .category(CredentialTypeMetadata.Category.TWO_FACTOR)
                .displayName("smsAuthenticator")
                .helpText("smsPhoneUpdate")
                .createAction(PhoneNumberRequiredAction.PROVIDER_ID)
                .removeable(true)
                .build(session);
    }

    @Override
    public String getType() {
        return SmsAuthCredentialModel.TYPE;
    }

    @Override
    public Stream<String> getDisableableCredentialTypesStream(RealmModel realm, UserModel user) {
        return Stream.empty();
    }

    @Override
    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/SmsAuthCredentialProviderFactory.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author Bill Burke
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator;

import org.keycloak.credential.CredentialProvider;
import org.keycloak.credential.CredentialProviderFactory;
import org.keycloak.models.KeycloakSession;

import netzbegruenung.keycloak.authenticator.credentials.SmsAuthCredentialModel;

public class SmsAuthCredentialProviderFactory implements CredentialProviderFactory<SmsAuthCredentialProvider> {

    public static final String PROVIDER_ID = "mobile-number";

    @Override
    public String getId() {
        return PROVIDER_ID;
    }

    @Override
    public CredentialProvider<SmsAuthCredentialModel> create(KeycloakSession session) {
        return new SmsAuthCredentialProvider(session);
    }
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/SmsAuthenticator.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @author Niko Köbler, https://www.n-k.de, @dasniko
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 */

package netzbegruenung.keycloak.authenticator;

import netzbegruenung.keycloak.authenticator.credentials.SmsAuthCredentialData;
import netzbegruenung.keycloak.authenticator.credentials.SmsAuthCredentialModel;
import netzbegruenung.keycloak.authenticator.gateway.SmsServiceFactory;

import org.jboss.logging.Logger;
import org.keycloak.authentication.CredentialValidator;
import org.keycloak.authentication.AuthenticationFlowContext;
import org.keycloak.authentication.AuthenticationFlowError;
import org.keycloak.authentication.Authenticator;
import org.keycloak.authentication.RequiredActionFactory;
import org.keycloak.authentication.RequiredActionProvider;
import org.keycloak.common.util.SecretGenerator;
import org.keycloak.credential.CredentialModel;
import org.keycloak.credential.CredentialProvider;
import org.keycloak.models.AuthenticationExecutionModel;
import org.keycloak.models.AuthenticatorConfigModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.RealmModel;
import org.keycloak.models.UserModel;
import org.keycloak.sessions.AuthenticationSessionModel;
import org.keycloak.theme.Theme;
import org.keycloak.util.JsonSerialization;

import jakarta.ws.rs.core.Response;
import java.util.Locale;
import java.util.Optional;
import java.io.IOException;
import java.util.Collections;
import java.util.List;

public class SmsAuthenticator implements Authenticator, CredentialValidator<SmsAuthCredentialProvider> {

	private static final Logger logger = Logger.getLogger(SmsAuthenticator.class);
	private static final String TPL_CODE = "login-sms.ftl";

	@Override
	public void authenticate(AuthenticationFlowContext context) {
		AuthenticatorConfigModel config = context.getAuthenticatorConfig();
		KeycloakSession session = context.getSession();
		UserModel user = context.getUser();
		RealmModel realm = context.getRealm();

		Optional<CredentialModel> model = context.getUser().credentialManager().getStoredCredentialsByTypeStream(SmsAuthCredentialModel.TYPE).findFirst();
		String mobileNumber;
		try {
			mobileNumber = JsonSerialization.readValue(model.orElseThrow().getCredentialData(), SmsAuthCredentialData.class).getMobileNumber();
		} catch (IOException e1) {
			logger.warn(e1.getMessage(), e1);
			return;
		}

		int length = Integer.parseInt(config.getConfig().get("length"));
		int ttl = Integer.parseInt(config.getConfig().get("ttl"));

		String code = SecretGenerator.getInstance().randomString(length, SecretGenerator.DIGITS);
		AuthenticationSessionModel authSession = context.getAuthenticationSession();
		authSession.setAuthNote("code", code);
		authSession.setAuthNote("ttl", Long.toString(System.currentTimeMillis() + (ttl * 1000L)));

		try {
			Theme theme = session.theme().getTheme(Theme.Type.LOGIN);
			Locale locale = session.getContext().resolveLocale(user);
			String smsAuthText = theme.getEnhancedMessages(realm,locale).getProperty("smsAuthText");
			String smsText = String.format(smsAuthText, code, Math.floorDiv(ttl, 60));

			SmsServiceFactory.get(config.getConfig()).send(mobileNumber, smsText);

			context.challenge(context.form().setAttribute("realm", realm).createForm(TPL_CODE));
		} catch (Exception e) {
			context.failureChallenge(AuthenticationFlowError.INTERNAL_ERROR,
				context.form().setError("smsAuthSmsNotSent", "Error. Use another method.")
					.createErrorPage(Response.Status.INTERNAL_SERVER_ERROR));
		}
	}

	@Override
	public void action(AuthenticationFlowContext context) {
		String enteredCode = context.getHttpRequest().getDecodedFormParameters().getFirst("code");

		AuthenticationSessionModel authSession = context.getAuthenticationSession();
		String code = authSession.getAuthNote("code");
		String ttl = authSession.getAuthNote("ttl");

		if (code == null || ttl == null) {
			context.failureChallenge(AuthenticationFlowError.INTERNAL_ERROR,
				context.form().createErrorPage(Response.Status.INTERNAL_SERVER_ERROR));
			return;
		}

		boolean isValid = enteredCode.equals(code);
		if (isValid) {
			if (Long.parseLong(ttl) < System.currentTimeMillis()) {
				// expired
				context.failureChallenge(AuthenticationFlowError.EXPIRED_CODE,
					context.form().setError("smsAuthCodeExpired").createErrorPage(Response.Status.BAD_REQUEST));
			} else {
				// valid
				context.success();
			}
		} else {
			// invalid
			AuthenticationExecutionModel execution = context.getExecution();
			if (execution.isRequired()) {
				context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS,
					context.form().setAttribute("realm", context.getRealm())
						.setError("smsAuthCodeInvalid").createForm(TPL_CODE));
			} else if (execution.isConditional() || execution.isAlternative()) {
				context.attempted();
			}
		}
	}

	@Override
	public boolean requiresUser() {
		return true;
	}

	@Override
	public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
		return getCredentialProvider(session).isConfiguredFor(realm, user, getType(session));
	}

	@Override
	public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {
		user.addRequiredAction(PhoneNumberRequiredAction.PROVIDER_ID);
	}

	public List<RequiredActionFactory> getRequiredActions(KeycloakSession session) {
		return Collections.singletonList((PhoneNumberRequiredActionFactory)session.getKeycloakSessionFactory().getProviderFactory(RequiredActionProvider.class, PhoneNumberRequiredAction.PROVIDER_ID));
	}

	@Override
	public void close() {
	}

	@Override
	public SmsAuthCredentialProvider getCredentialProvider(KeycloakSession session) {
		return (SmsAuthCredentialProvider)session.getProvider(CredentialProvider.class, SmsAuthCredentialProviderFactory.PROVIDER_ID);
	}
}

================
File: sms-authenticator/src/main/java/netzbegruenung/keycloak/authenticator/SmsAuthenticatorFactory.java
================
/*
 * Copyright 2016 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
 * @author Netzbegruenung e.V.
 * @author verdigado eG
 * @author Niko Köbler, https://www.n-k.de, @dasniko
 */

package netzbegruenung.keycloak.authenticator;

import org.keycloak.Config;
import org.keycloak.authentication.Authenticator;
import org.keycloak.authentication.AuthenticatorFactory;
import org.keycloak.models.AuthenticationExecutionModel;
import org.keycloak.models.KeycloakSession;
import org.keycloak.models.KeycloakSessionFactory;
import org.keycloak.provider.ProviderConfigProperty;

import java.util.Collections;
import java.util.List;

public class SmsAuthenticatorFactory implements AuthenticatorFactory {

	public static final String PROVIDER_ID = "mobile-number-authenticator";
	private static final SmsAuthenticator SINGLETON = new SmsAuthenticator();


	@Override
	public String getId() {
		return PROVIDER_ID;
	}

	@Override
	public Authenticator create(KeycloakSession session) {
		return SINGLETON;
	}

	private static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
		AuthenticationExecutionModel.Requirement.REQUIRED,
		AuthenticationExecutionModel.Requirement.ALTERNATIVE,
		AuthenticationExecutionModel.Requirement.DISABLED
	};
	@Override
	public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
		return REQUIREMENT_CHOICES;
	}

	@Override
	public boolean isConfigurable() {
		return true;
	}

	@Override
	public boolean isUserSetupAllowed() {
		return true;
	}

	@Override
	public List<ProviderConfigProperty> getConfigProperties() {
		return List.of(
			new ProviderConfigProperty("length", "Code length", "The number of digits of the generated code.", ProviderConfigProperty.STRING_TYPE, 6),
			new ProviderConfigProperty("ttl", "Time-to-live", "The time to live in seconds for the code to be valid.", ProviderConfigProperty.STRING_TYPE, "300"),
			new ProviderConfigProperty("senderId", "SenderId", "The sender ID is displayed as the message sender on the receiving device.", ProviderConfigProperty.STRING_TYPE, "Keycloak"),
			new ProviderConfigProperty("simulation", "Simulation mode", "In simulation mode, the SMS won't be sent, but printed to the server logs", ProviderConfigProperty.BOOLEAN_TYPE, true),
			new ProviderConfigProperty("countrycode", "Default country prefix", "Default country prefix that is assumed if user does not provide one.", ProviderConfigProperty.STRING_TYPE, "+49"),
			new ProviderConfigProperty("apiurl", "SMS API URL", "The path to the API that receives an HTTP request.", ProviderConfigProperty.STRING_TYPE, "https://example.com/api/sms/send"),
			new ProviderConfigProperty("urlencode", "URL encode data", "By default send a JSON in HTTP POST body. You can URL encode the data instead.", ProviderConfigProperty.BOOLEAN_TYPE, false),
			new ProviderConfigProperty("apitokenattribute", "API Secret Token Attribute (optional)", "Name of attribute that contains your API token/secret. In some APIs the secret is already configured in the path. In this case, this can be left empty.", ProviderConfigProperty.STRING_TYPE, ""),
			new ProviderConfigProperty("apitoken", "API Secret (optional)", "Your API secret. If a Basic Auth user is set, this will be the Basic Auth password.", ProviderConfigProperty.STRING_TYPE, "changeme"),
			new ProviderConfigProperty("apiuser", "Basic Auth Username (optional)", "If set, Basic Auth will be performed. Leave empty if not required.", ProviderConfigProperty.STRING_TYPE, ""),
			new ProviderConfigProperty("messageattribute", "Message Attribute", "The attribute that contains the SMS message text.", ProviderConfigProperty.STRING_TYPE, "text"),
			new ProviderConfigProperty("receiverattribute", "Receiver Phone Number Attribute", "The attribute that contains the receiver phone number.", ProviderConfigProperty.STRING_TYPE, "to"),
			new ProviderConfigProperty("receiverJsonTemplate", "Receiver Phone Number Json value template", "Receiver value structure can be customised to match API requirements.", ProviderConfigProperty.STRING_TYPE, "\"%s\""),
			new ProviderConfigProperty("senderattribute", "Sender Phone Number Attribute", "The attribute that contains the sender phone number. Leave empty if not required.", ProviderConfigProperty.STRING_TYPE, "from"),
			new ProviderConfigProperty("forceSecondFactor", "Force 2FA", "If 2FA authentication is not configured, the user is forced to setup SMS Authentication.", ProviderConfigProperty.BOOLEAN_TYPE, false),
			new ProviderConfigProperty("whitelist", "Excluded from enforced 2FA", "All users with the here selected role are not forced to setup 2FA.", ProviderConfigProperty.ROLE_TYPE, null),
			new ProviderConfigProperty("hideResponsePayload", "Redacted API response log message", "Don't log API response body of SMS send request.", ProviderConfigProperty.BOOLEAN_TYPE, false),
			new ProviderConfigProperty("mobileInputFieldPlaceholder", "Phone number input field placeholder", "The placeholder string user in the phone number input field", ProviderConfigProperty.STRING_TYPE, ""),
			new ProviderConfigProperty("storeInAttribute", "Set phone number as attribute", "Sets the phone number as a user attribute.", ProviderConfigProperty.BOOLEAN_TYPE, false),
			new ProviderConfigProperty("normalizePhoneNumber", "Format phone number", "Normalize the phone number using the E164 standard.", ProviderConfigProperty.BOOLEAN_TYPE, false),
			new ProviderConfigProperty("numberTypeFilters", "Valid number type filters", "A list of valid number types to filter the input phone number by. Possible values are: FIXED_LINE, MOBILE, "
				+ " FIXED_LINE_OR_MOBILE, PAGER, TOLL_FREE, PREMIUM_RATE, SHARED_COST, PERSONAL_NUMBER, VOIP, UAN, VOICEMAIL.", ProviderConfigProperty.MULTIVALUED_STRING_TYPE, Collections.emptyList()),
			new ProviderConfigProperty("forceRetryOnBadFormat", "Ask for new number if checks fail", "Sets an error message and asks the user to re-enter phone number if formatting checks are not successfully passed.", ProviderConfigProperty.BOOLEAN_TYPE, false)
		);
	}

	@Override
	public String getHelpText() {
		return "Validates an OTP sent via SMS to the users mobile phone.";
	}

	@Override
	public String getDisplayType() {
		return "SMS Authentication (2FA)";
	}

	@Override
	public String getReferenceCategory() {
		return "mobile-number";
	}

	@Override
	public void init(Config.Scope config) {
	}

	@Override
	public void postInit(KeycloakSessionFactory factory) {
	}

	@Override
	public void close() {
	}

}

================
File: sms-authenticator/src/main/resources/META-INF/services/org.keycloak.authentication.AuthenticatorFactory
================
netzbegruenung.keycloak.authenticator.SmsAuthenticatorFactory

================
File: sms-authenticator/src/main/resources/META-INF/services/org.keycloak.authentication.RequiredActionFactory
================
netzbegruenung.keycloak.authenticator.PhoneNumberRequiredActionFactory
netzbegruenung.keycloak.authenticator.PhoneValidationRequiredActionFactory

================
File: sms-authenticator/src/main/resources/META-INF/services/org.keycloak.credential.CredentialProviderFactory
================
netzbegruenung.keycloak.authenticator.SmsAuthCredentialProviderFactory

================
File: sms-authenticator/src/main/resources/theme-resources/messages/messages_de.properties
================
smsAuthText=Ihr SMS Code lautet %1$s und ist g\u00FCltig f\u00FCr %2$d Minuten.

smsAuthTitle=SMS Code
smsAuthLabel=SMS Code
smsAuthInstruction=Geben Sie den SMS Code ein, den wir an Ihr Ger\u00E4t gesendet haben.

smsAuthSmsNotSent=Die SMS konnte nicht gesendet werden. Grund: {0}
smsAuthCodeExpired=Der SMS Code ist abgelaufen.
smsAuthCodeInvalid=Ung\u00FCltiger SMS Code, bitte erneut eingeben.

smsPhoneNumberTitle=Bitte gib deine Telefonnummer ein
smsPhoneNumberLabel=Telefonnummer
smsPhoneNumberInstructions=Bitte gib eine Telefonnummer inklusive L\u00E4ndervorwahl (+49) f\u00FCr den SMS-Empfang an. Beispiel: Wenn deine Telefonnummer 0170 1234567 lautet, dann gib bitte +49 170 1234567 ein.

smsPhoneUpdate=Empfange einen Einmal-Code per SMS auf dein Telefon.
smsAuthenticator=SMS Authentifizierung

doSubmitMobile=Code per SMS erhalten

numberFormatFailedToParse=Die Telefonnummer konnte nicht verarbeitet werden. Bitte versuche es erneut.
numberFormatNoMatchingFilters=Diese Telefonnummer ist nicht g\u00FCltig. Bitte nutze eine regul\u00E4re Mobilfunk- oder Festnetznummer.
numberFormatNumberInvalid=Ung\u00FCltige Telefonnummer. Bitte versuche es erneut.

mobile-number-display-name=SMS Authentifizierung

================
File: sms-authenticator/src/main/resources/theme-resources/messages/messages_en.properties
================
smsAuthText=Your SMS code is %1$s and is valid for %2$d minutes.

smsAuthTitle=SMS Code
smsAuthLabel=SMS Code
smsAuthInstruction=Enter the code we sent to your device.

smsAuthSmsNotSent=The SMS could not be sent, because of {0}
smsAuthCodeExpired=The SMS code has expired.
smsAuthCodeInvalid=Invalid SMS code entered, please enter it again.

smsPhoneNumberTitle=Please enter your phone number
smsPhoneNumberLabel=Phone Number
smsPhoneNumberInstructions=Enter the phone number, including your contry code, for 2FA SMS Authentication.

smsPhoneUpdate=Receive a one time code via SMS on your phone.
smsAuthenticator=SMS Authenticator

doSubmitMobile=Get SMS Code

numberFormatFailedToParse=Failed to parse the phone number, please enter it again.
numberFormatNoMatchingFilters=Phone number format is not allowed. Please use a regular mobile or fixed line number.
numberFormatNumberInvalid=Phone number invalid, please enter it again.

mobile-number-display-name=SMS Authenticator

================
File: sms-authenticator/src/main/resources/theme-resources/messages/messages_fi.properties
================
smsAuthText=Vahvistuskoodisi on %1$s ja se on voimassa %2$d minuuttia.

smsAuthTitle=Vahvistuskoodi
smsAuthLabel=Vahvistuskoodi
smsAuthInstruction=Syצtה koodi, jonka lהhetimme laitteeseesi.

smsAuthSmsNotSent=Tekstiviestiה ei voitu lהhettהה, koska {0}
smsAuthCodeExpired=Vahvistuskoodi on vanhentunut.
smsAuthCodeInvalid=Virheellinen vahvistuskoodi, syצtה se uudelleen.

smsPhoneNumberTitle=Syצtה puhelinnumerosi
smsPhoneNumberLabel=Puhelinnumero
smsPhoneNumberInstructions=Syצtה puhelinnumero, mukaan lukien maakoodi, kaksivaiheista tunnistautumista varten.

smsPhoneUpdate=Kirjaudu kertakהyttצisellה tekstiviestikoodilla.
smsAuthenticator=Tekstiviestitunnistautuminen

doSubmitMobile=Lהhetה vahvistuskoodi

numberFormatFailedToParse=Puhelinnumeron kהsittely epהonnistui, syצtה se uudelleen.
numberFormatNoMatchingFilters=Puhelinnumeron muoto ei ole sallittu. Kהytה tavallista matkapuhelin- tai lankapuhelinnumeroa.
numberFormatNumberInvalid=Virheellinen puhelinnumero, syצtה se uudelleen.

mobile-number-display-name=SMS-tunnistautuminen

================
File: sms-authenticator/src/main/resources/theme-resources/templates/login-sms.ftl
================
<#import "template.ftl" as layout>
<@layout.registrationLayout displayInfo=true; section>
	<#if section = "header">
		${msg("smsAuthTitle",realm.displayName)}
	<#elseif section = "form">
		<form onsubmit="login.disabled = true; return true;" id="kc-sms-code-login-form" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
			<div class="${properties.kcFormGroupClass!}">
				<div class="${properties.kcLabelWrapperClass!}">
					<label for="code" class="${properties.kcLabelClass!}">${msg("smsAuthLabel")}</label>
				</div>
				<div class="${properties.kcInputWrapperClass!}">
					<input type="number" min="0" inputmode="numeric" pattern="[0-9]*" id="code" name="code" class="${properties.kcInputClass!}" autocomplete="off" autofocus />
				</div>
			</div>
			<div class="${properties.kcFormGroupClass!} ${properties.kcFormSettingClass!}">
				<div id="kc-form-options" class="${properties.kcFormOptionsClass!}">
					<div class="${properties.kcFormOptionsWrapperClass!}">
						<span><a href="/">${msg("backToApplication")?no_esc}</a></span>
					</div>
				</div>

				<div id="kc-form-buttons" class="${properties.kcFormButtonsClass!}">
					<input name="login" class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}" type="submit" value="${msg("doSubmit")}"/>
				</div>
			</div>
		</form>
	<#elseif section = "info" >
		${msg("smsAuthInstruction")}
	</#if>
</@layout.registrationLayout>

================
File: sms-authenticator/src/main/resources/theme-resources/templates/mobile_number_form.ftl
================
<#import "template.ftl" as layout>
<@layout.registrationLayout displayInfo=true; section>
	<#if section = "header">
		${msg("smsPhoneNumberTitle",realm.displayName)}
	<#elseif section = "form">
		<form onsubmit="phonenumber.disabled = true; return true;" id="kc-sms-code-login-form" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
			<div class="${properties.kcFormGroupClass!}">
				<div class="${properties.kcLabelWrapperClass!}">
					<label for="code" class="${properties.kcLabelClass!}">${msg("smsPhoneNumberLabel")}</label>
				</div>
				<div class="${properties.kcInputWrapperClass!}">
					<input type="tel" id="code" pattern="[0-9\+\-\.\ ]" name="mobile_number" class="${properties.kcInputClass!}" placeholder="${mobileInputFieldPlaceholder!}" autofocus />
				</div>
			</div>
			<div class="${properties.kcFormGroupClass!} ${properties.kcFormSettingClass!}">
				<div id="kc-form-options" class="${properties.kcFormOptionsClass!}">
					<div class="${properties.kcFormOptionsWrapperClass!}">
						<span><a href="/">${msg("backToApplication")?no_esc}</a></span>
					</div>
				</div>

				<div id="kc-form-buttons" class="${properties.kcFormButtonsClass!}">
					<input name="phonenumber" class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}" type="submit" value="${msg("doSubmitMobile")}" />
				</div>
			</div>
		</form>
	<#elseif section = "info" >
		${msg("smsPhoneNumberInstructions")}
	</#if>
</@layout.registrationLayout>

================
File: sms-authenticator/pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <artifactId>sms-authenticator</artifactId>

    <parent>
        <groupId>netzbegruenung</groupId>
        <artifactId>keycloak-mfa-tools</artifactId>
        <version>26.1.2</version>
    </parent>

    <dependencies>
		<dependency>
			<groupId>org.keycloak</groupId>
			<artifactId>keycloak-quarkus-server-app</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>com.googlecode.libphonenumber</groupId>
			<artifactId>libphonenumber</artifactId>
			<version>8.13.54</version>
		</dependency>
		<!-- Necessary for proper execution of IDELauncher -->
		<!-- Can be removed as part of the https://github.com/keycloak/keycloak/issues/22455 enhancement -->
		<dependency>
			<groupId>io.quarkus</groupId>
			<artifactId>quarkus-vertx-http-dev-ui-resources</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- this dependency is necessary to start the IDELauncher -->
		<dependency>
			<groupId>com.oracle.database.jdbc</groupId>
			<artifactId>ojdbc11</artifactId>
			<scope>provided</scope>
		</dependency>
		<!-- https://github.com/keycloak/keycloak/issues/34549 -->
		<dependency>
			<groupId>io.mvnpm</groupId>
			<artifactId>importmap</artifactId>
			<scope>provided</scope>
		</dependency>
    </dependencies>

    <build>
        <finalName>${project.groupId}.${project.artifactId}-v${project.version}</finalName>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
            </plugin>
			<plugin>
				<groupId>io.quarkus</groupId>
				<artifactId>quarkus-maven-plugin</artifactId>
				<configuration>
					<argsString>start-dev --db-url jdbc:h2:file:${project.parent.basedir}/h2db/sms;AUTO_SERVER=TRUE;NON_KEYWORDS=VALUE</argsString>
				</configuration>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-shade-plugin</artifactId>
				<executions>
					<execution>
						<phase>package</phase>
						<goals>
							<goal>shade</goal>
						</goals>
						<configuration>
							<artifactSet>
								<includes>
									<include>com.googlecode.libphonenumber:libphonenumber</include>
								</includes>
							</artifactSet>
							<filters>
								<filter>
									<artifact>com.googlecode.libphonenumber:libphonenumber</artifact>
									<excludes>
										<exclude>META-INF/MANIFEST.MF</exclude>
									</excludes>
								</filter>
							</filters>
						</configuration>
					</execution>
				</executions>
			</plugin>
        </plugins>
    </build>

</project>

================
File: sms-authenticator/README.md
================
# Keycloak 2FA SMS Authenticator

Keycloak Authentication Provider implementation to get a 2nd-factor authentication with a OTP/code/token send via SMS with a configurable HTTPS API.
It should be possible to interact with most SMS providers. Issues and pull requests to support more SMS providers are welcome.

This is a fork of a great demo implementation by [@dasniko](https://github.com/dasniko/keycloak-2fa-sms-authenticator), and also takes huge chunks of code
from the original authenticator provider [documentation](https://www.keycloak.org/docs/latest/server_development/index.html#_auth_spi) and [example](https://github.com/keycloak/keycloak/tree/main/examples/providers/authenticator) from Keycloak itself.

# Installing
1. Go to https://github.com/netzbegruenung/keycloak-mfa-plugins/releases and download
   the latest .jar file.
1. Copy the created jar file into the `providers` directory of your Keycloak:
   ```shell
   cp netzbegruenung.keycloak-2fa-sms-authenticator.jar /path/to/keycloak/providers
   ```
1. Run the `build` command and restart Keycloak:
   ```shell
   /path/to/keycloak/bin/kc.sh build [your-additional-flags]
   systemctl restart keycloak.service
   ```

# Setup
1. Navigate to your Authentication flow configuration: https://keycloak.example.com/admin/master/console/#/YOUR-REALM/authentication. Then edit the `Browser flow`.
1. Add a new step next to the `OTP Form` step. Choose the `SMS Authentication (2FA)` authenticator and set it to `Alternative`.
1. Make sure that you name it `sms-2fa`. This is currently a hack that will hopefully be fixed. Additional executions with other names can be added. But this first execution will be used for the confirmation SMS when setting up a new phone number.
1. Go into the config of the execution and configure the plugin so that it works with the API of your SMS proivder HTTP API. The data is always sent in a HTTP POST request. Refer to the API documentation of your provider to choose the correct configuration values. The details of the request can be configured with the following configuration options:
   1. `SMS API URL`: the URL to which the HTTP POST request should be sent.
   1. `URL encode data`: When off, the data will be sent as an `application/json` body. When on, the data will be encoded as URL parameters.
   1. `API Secret Token Attribute (optional)`: Name of attribute that contains your API token/secret. In some APIs the secret is already configured in the path. In this case, this can be left empty.
   1. `API Secret (optional)`: Your API secret. If a Basic Auth user is set, this will be the Basic Auth password. If `API Secret Token Attribute` is set, this secret will be sent as the value to the given attribute name.
   1. `Basic Auth Username (optional)`: If set, Basic Auth will be performed. Leave empty if not required.
   1. `Message Attribute`: The attribute that contains the SMS message text. For many APIs (i.e. GTX Messaging, SMS Eagle) this is `text`.
   1. `Receiver Phone Number Attribute`: The attribute that contains the receiver phone number. For many APIs (i.e. GTX Messaging, SMS Eagle) this is `to`.
   1. `Sender Phone Number Attribute`: The attribute that contains the sender phone number. Leave empty if not required.
   1. `SenderId`: The sender ID is displayed as the message sender on the receiving device. This is the value for the `Sender Phone Number Attribute`.
1. Go to `/admin/master/console/#/realm/authentication/required-actions` and enable required actions "Phone Validation" and "Update Mobile Number"

# Usage
After successfully configured the authenticator and the required actions users can set up SMS Authentication in the
account console `/realms/realm/account/#/account-security/signing-in` by entering and confirming their phone number.

# Enforce SMS 2FA
If the option `Force 2FA` in the SMS Authenticator config is enabled and a user has no other 2FA method already enabled,
users will have to set up the SMS Authenticator.

================
File: .editorconfig
================
# http://editorconfig.org
root = true

[*]
charset = utf-8
indent_style = tab
indent_size = 4
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

[*.yml]
indent_size = 2

[*.yaml]
indent_size = 2

================
File: .gitignore
================
.idea
*.iml
target
copy.sh
dependency-reduced-pom.xml
.classpath
.project
.settings
.jpb

h2db/*.db

================
File: LICENSE
================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

=============================================================================

MIT License

Copyright (c) 2020 Niko Köbler
Copyright (c) 2022 Netzbegrünung e.V.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
				 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>netzbegruenung</groupId>
	<artifactId>keycloak-mfa-tools</artifactId>
	<packaging>pom</packaging>
	<version>26.1.2</version>

	<modules>
		<module>sms-authenticator</module>
        <module>app-authenticator</module>
		<module>enforce-mfa</module>
	</modules>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<keycloak.version>26.1.2</keycloak.version>
		<maven.compiler.release>17</maven.compiler.release>
		<maven.compiler.version>3.13.0</maven.compiler.version>
		<maven.shade.version>3.6.0</maven.shade.version>
		<maven.surefire.version>3.5.2</maven.surefire.version>
		<quarkus.version>3.15.3</quarkus.version>
	</properties>

	<dependencyManagement>
		<dependencies>

			<dependency>
				<groupId>org.keycloak</groupId>
				<artifactId>keycloak-dependencies-server-all</artifactId>
				<version>${keycloak.version}</version>
				<scope>import</scope>
				<type>pom</type>
			</dependency>

			<dependency>
				<groupId>org.keycloak</groupId>
				<artifactId>keycloak-quarkus-server-app</artifactId>
				<version>${keycloak.version}</version>
			</dependency>

			<dependency>
				<groupId>io.quarkus</groupId>
				<artifactId>quarkus-vertx-http-dev-ui-resources</artifactId>
				<version>${quarkus.version}</version>
			</dependency>

		</dependencies>
	</dependencyManagement>

	<build>
		<pluginManagement>
			<plugins>

				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-compiler-plugin</artifactId>
					<version>${maven.compiler.version}</version>
				</plugin>

				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-shade-plugin</artifactId>
					<version>${maven.shade.version}</version>
				</plugin>

				<plugin>
					<groupId>org.apache.maven.plugins</groupId>
					<artifactId>maven-surefire-plugin</artifactId>
					<version>${maven.surefire.version}</version>
				</plugin>

				<plugin>
					<groupId>io.quarkus</groupId>
					<artifactId>quarkus-maven-plugin</artifactId>
					<version>${quarkus.version}</version>
					<executions>
						<execution>
							<goals>
								<goal>build</goal>
							</goals>
						</execution>
					</executions>
					<configuration>
						<systemProperties>
							<java.util.concurrent.ForkJoinPool.common.threadFactory>
								io.quarkus.bootstrap.forkjoin.QuarkusForkJoinWorkerThreadFactory
							</java.util.concurrent.ForkJoinPool.common.threadFactory>
						</systemProperties>
					</configuration>
				</plugin>
			</plugins>
		</pluginManagement>
	</build>

</project>

================
File: README.md
================
# Keycloak MFA Plugin collection

This repository contains the source code for a collection of Keycloak MFA plugins. The plugins are:
* [SMS authenticator](sms-authenticator/README.md): Provides SMS as authentication step. SMS are sent via HTTP API, which can be configured. (production ready)
* [Enforce MFA](enforce-mfa/README.md): Force users to configure a second factor after logging in. (beta)
* [Native App MFA integration](app-authenticator/README.md): connect a mobile app to Keycloak which receives a notification about a pending login process and allows the user to allow/block the login request. (work in progress)

The different plugins are documented in the submodules README. If you need support for deployment or adjustments, please contact [support@verdigado.com](mailto:support@verdigado.com).

## License
The code of this project is Apache 2.0 licensed. Parts of the original code are MIT licensed.

## Development
Run the Quarkus distribution in development mode for live reloading and debugging similar to: https://github.com/keycloak/keycloak/tree/main/quarkus#contributing

```shell
mvn -f some_module/pom.xml compile quarkus:dev
```

Works great:)
https://github.com/keycloak/keycloak/discussions/11841

If problems occur, check that quarkus-maven-plugin is in sync with keycloaks quarkus version.
Maven does not support builtin import of properties beside inheritance.

## Building

1. Clone this repository
1. Install Apache Maven
1. Change into the cloned directory and run
   ```shell
   mvn clean install
   ```
   A file `target/netzbegruenung.keycloak-2fa-sms-authenticator.jar` should be created.

If building fails and the problem is caused or related to the dev module or tests, try to run `mvn clean install -DskipTests`.

## Releases
Deployment is done by github actions: `.github/workflows/release.yml`
To trigger the release workflow be sure to have proper access rights and follow the steps below.
https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules#about-tag-protection-rules

1. Update project and submodules version `mvn versions:set -DnewVersion=1.2.3; mvn versions:commit`
1. Commit your changes
1. Add tag to your commit `git tag -a v1.2.3 -m "Bump version 1.2.3"`
1. Trigger the release by `git push --tags`

After building completes the new release is available on github containing the jar files for each module.
